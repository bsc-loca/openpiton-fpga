// Modified by Barcelona Supercomputing Center on March 3rd, 2022
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

`include "define.tmp.h"
`include "piton_system.vh"
`include "mc_define.h"
`ifdef PITONSYS_AXI4_MEM
`include "noc_axi4_bridge_define.vh"
`endif
`include "uart16550_define.vh"
`include "chipset_define.vh"

// Filename: chipset_impl.v
// Author: mmckeown
// Description: Top-level chipset implementation.  Instantiates
//              different versions of chipsets based on different
//              macros.  Some logic is common to all chipset implementations.

// Macros used in this file:
//  PITON_FPGA_MC_DDR3                  Set to indicate an FPGA implementation will
//                                      use a DDR2/3 memory controller.  If
//                                      this is not set, a default "fake"
//                                      simulated DRAM is used.
//  PITONSYS_NO_MC                      If set, no memory controller is used. This is used
//                                      in the testing of the Piton system, where a small test
//                                      can be run on the chip with DRAM
//                                      emulated in BRAMs
//  PITONSYS_IOCTRL                     Set to use real I/O controller, otherwise a fake I/O bridge
//                                      is used and emulates I/O in PLI C calls.  This may not be compatible
//                                      with the "fake" memory controller or no memory controller at all
//  PITONSYS_UART                       Set to include a UART in the Piton system chipset.  The UART
//                                      can be used as an I/O device and/or a device for bootloading
//                                      test programs (see PITONSYS_UART_BOOT)
//  PITONSYS_UART_LOOBACK               Set to looback UART to itself.  Used for testing purposes
//  PITONSYS_UART_BOOT                  Set for UART boot hardware to be included.  If this is the
//                                      only boot option set, it is always used.  If there is another
//                                      boot option, a switch can be used to enable UART boot
//  PITONSYS_SPI                        Set to include a SPI in the Piton system chipset.  SPI is generally
//                                      used for SD card boot, but could potentially be used for other
//                                      purposes
//  NEXYS4DDR_BOARD NEXYSVIDEO_BOARD    Used to indicate which board this code is
//                                      being synthesized for. There are more than just these
<%
import os
import sys
import pyhplib
from pyhplib import *
devices = pyhplib.ReadDevicesXMLFile()

sys.path.append(os.environ["DV_ROOT"]+"/design/chipset/io_xbar/parameter")
import io_xbar_node_define

DYNAMIC_NODE_PORT = io_xbar_node_define.DYNAMIC_NODE_PORT
%>

module chipset_impl(
    // Clocks and resets
    input                                       chipset_clk,
    input                                       chipset_rst_n,
    input                                       piton_ready_n,

    output                                      test_start,
    output                                      uart_rst_out_n,

    // invalid access inside packet filter
    output                                      invalid_access_o,

`ifndef PITONSYS_NO_MC
`ifdef PITON_FPGA_MC_DDR3
`ifndef F1_BOARD
`ifdef PITONSYS_DDR4
  `ifndef PITONSYS_MEEP
    input                                       mc_clk_p,
    input                                       mc_clk_n,
  `else
    input mc_clk,
  `endif
`else  // PITONSYS_DDR4
    input                                       mc_clk,
`endif // PITONSYS_DDR4
`endif // ifndef F1_BOARD
`endif // endif PITON_FPGA_MC_DDR3
`endif // endif PITONSYS_NO_MC

    // Main chip interface
    output [`NOC_DATA_WIDTH-1:0]                chipset_intf_data_noc1,
    output [`NOC_DATA_WIDTH-1:0]                chipset_intf_data_noc2,
    output [`NOC_DATA_WIDTH-1:0]                chipset_intf_data_noc3,
    output                                      chipset_intf_val_noc1,
    output                                      chipset_intf_val_noc2,
    output                                      chipset_intf_val_noc3,
    input                                       chipset_intf_rdy_noc1,
    input                                       chipset_intf_rdy_noc2,
    input                                       chipset_intf_rdy_noc3,

    input  [`NOC_DATA_WIDTH-1:0]                intf_chipset_data_noc1,
    input  [`NOC_DATA_WIDTH-1:0]                intf_chipset_data_noc2,
    input  [`NOC_DATA_WIDTH-1:0]                intf_chipset_data_noc3,
    input                                       intf_chipset_val_noc1,
    input                                       intf_chipset_val_noc2,
    input                                       intf_chipset_val_noc3,
    output                                      intf_chipset_rdy_noc1,
    output                                      intf_chipset_rdy_noc2,
    output                                      intf_chipset_rdy_noc3,

  `ifdef PITON_EXTRA_MEMS    
    input  [`PITON_EXTRA_MEMS * `NOC_DATA_WIDTH -1:0] intf_mcx_data_noc2,
    input  [`PITON_EXTRA_MEMS-1:0]                    intf_mcx_val_noc2,
    output [`PITON_EXTRA_MEMS-1:0]                    intf_mcx_rdy_noc2,

    output [`PITON_EXTRA_MEMS * `NOC_DATA_WIDTH -1:0] mcx_intf_data_noc3,
    output [`PITON_EXTRA_MEMS-1:0]                    mcx_intf_val_noc3,
    input  [`PITON_EXTRA_MEMS-1:0]                    mcx_intf_rdy_noc3,
  `endif

    // DRAM and I/O interfaces
`ifndef PITONSYS_NO_MC
`ifdef PITON_FPGA_MC_DDR3    
    output                                      init_calib_complete,
`ifndef F1_BOARD
    // Generalized interface for any FPGA board we support.
    // Not all signals will be used for all FPGA boards (see constraints)
`ifdef PITONSYS_DDR4    
    output                                      ddr_act_n,
    output [`DDR3_BG_WIDTH-1:0]                 ddr_bg,
`else // PITONSYS_DDR4   
    output                                      ddr_cas_n,
    output                                      ddr_ras_n,
    output                                      ddr_we_n,
`endif // PITONSYS_DDR4
    output [`DDR3_ADDR_WIDTH-1:0]               ddr_addr,
    output [`DDR3_BA_WIDTH-1:0]                 ddr_ba,
    output [`DDR3_CK_WIDTH-1:0]                 ddr_ck_n,
    output [`DDR3_CK_WIDTH-1:0]                 ddr_ck_p,
    output [`DDR3_CKE_WIDTH-1:0]                ddr_cke,
    output                                      ddr_reset_n,
    inout  [`DDR3_DQ_WIDTH-1:0]                 ddr_dq,
    inout  [`DDR3_DQS_WIDTH-1:0]                ddr_dqs_n,
    inout  [`DDR3_DQS_WIDTH-1:0]                ddr_dqs_p,
`ifndef NEXYSVIDEO_BOARD
    output [`DDR3_CS_WIDTH-1:0]                 ddr_cs_n,
`endif // endif NEXYSVIDEO_BOARD
`ifdef PITONSYS_DDR4
  `ifdef PITONSYS_PCIE
    input  [15:0] pci_express_x16_rxn,
    input  [15:0] pci_express_x16_rxp,
    output [15:0] pci_express_x16_txn,
    output [15:0] pci_express_x16_txp,  
    output [4:0] pcie_gpio,      
    input  pcie_perstn,
    input  pcie_refclk_n,
    input  pcie_refclk_p,
 `endif
`ifdef XUPP3R_BOARD
    output                                      ddr_parity,
`elsif ALVEOU280_BOARD
   `ifdef PITONSYS_MEEP
    input                           hbm_calib_complete,
    // regular MC AXI bus
    output wire [`AXI4_ID_WIDTH     -1:0]    m_axi_awid,
    output wire [`AXI4_ADDR_WIDTH   -1:0]    m_axi_awaddr,
    output wire [`AXI4_LEN_WIDTH    -1:0]    m_axi_awlen,
    output wire [`AXI4_SIZE_WIDTH   -1:0]    m_axi_awsize,
    output wire [`AXI4_BURST_WIDTH  -1:0]    m_axi_awburst,
    output wire                              m_axi_awlock,
    output wire [`AXI4_CACHE_WIDTH  -1:0]    m_axi_awcache,
    output wire [`AXI4_PROT_WIDTH   -1:0]    m_axi_awprot,
    output wire [`AXI4_QOS_WIDTH    -1:0]    m_axi_awqos,
    output wire [`AXI4_REGION_WIDTH -1:0]    m_axi_awregion,
    output wire [`AXI4_USER_WIDTH   -1:0]    m_axi_awuser,
    output wire                              m_axi_awvalid,
    input  wire                              m_axi_awready,

    output wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_wid,
    output wire  [`AXI4_DATA_WIDTH   -1:0]    m_axi_wdata,
    output wire  [`AXI4_STRB_WIDTH   -1:0]    m_axi_wstrb,
    output wire                               m_axi_wlast,
    output wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_wuser,
    output wire                               m_axi_wvalid,
    input  wire                               m_axi_wready,

    output wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_arid,
    output wire  [`AXI4_ADDR_WIDTH   -1:0]    m_axi_araddr,
    output wire  [`AXI4_LEN_WIDTH    -1:0]    m_axi_arlen,
    output wire  [`AXI4_SIZE_WIDTH   -1:0]    m_axi_arsize,
    output wire  [`AXI4_BURST_WIDTH  -1:0]    m_axi_arburst,
    output wire                               m_axi_arlock,
    output wire  [`AXI4_CACHE_WIDTH  -1:0]    m_axi_arcache,
    output wire  [`AXI4_PROT_WIDTH   -1:0]    m_axi_arprot,
    output wire  [`AXI4_QOS_WIDTH    -1:0]    m_axi_arqos,
    output wire  [`AXI4_REGION_WIDTH -1:0]    m_axi_arregion,
    output wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_aruser,
    output wire                               m_axi_arvalid,
    input  wire                               m_axi_arready,

    input  wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_rid,
    input  wire  [`AXI4_DATA_WIDTH   -1:0]    m_axi_rdata,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    m_axi_rresp,
    input  wire                               m_axi_rlast,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_ruser,
    input  wire                               m_axi_rvalid,
    output wire                               m_axi_rready,

    input  wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_bid,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    m_axi_bresp,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_buser,
    input  wire                               m_axi_bvalid,
    output wire                               m_axi_bready,

    // ETHERNET
     input wire                               eth_axi_aclk,
     input wire                               eth_axi_arstn,
     input wire   [1:0 ]                      eth_irq,

    `ifdef ETHERNET_DMA
     output [`C_M_AXI_LITE_ADDR_WIDTH-1:0]   dma_s_axi_awaddr,
     output                                  dma_s_axi_awvalid,
     input                                   dma_s_axi_awready,
                                      
     output [`C_M_AXI_LITE_DATA_WIDTH-1:0]   dma_s_axi_wdata,
     output [`C_M_AXI_LITE_DATA_WIDTH/8-1:0] dma_s_axi_wstrb,
     output                                  dma_s_axi_wvalid,
     input                                   dma_s_axi_wready,
                                      
     input  [`C_M_AXI_LITE_RESP_WIDTH-1:0]   dma_s_axi_bresp,
     input                                   dma_s_axi_bvalid,
     output                                  dma_s_axi_bready,
                                      
     output [`C_M_AXI_LITE_ADDR_WIDTH-1:0]   dma_s_axi_araddr,
     output                                  dma_s_axi_arvalid,
     input                                   dma_s_axi_arready,
                                      
     input  [`C_M_AXI_LITE_DATA_WIDTH-1:0]   dma_s_axi_rdata,
     input  [`C_M_AXI_LITE_RESP_WIDTH-1:0]   dma_s_axi_rresp,
     input                                   dma_s_axi_rvalid,
     output                                  dma_s_axi_rready,

    `else
	   // AXI interface
    output wire [`AXI4_ID_WIDTH     -1:0]    eth_axi_awid,
    output wire [`AXI4_ADDR_WIDTH   -1:0]    eth_axi_awaddr,
    output wire [`AXI4_LEN_WIDTH    -1:0]    eth_axi_awlen,
    output wire [`AXI4_SIZE_WIDTH   -1:0]    eth_axi_awsize,
    output wire [`AXI4_BURST_WIDTH  -1:0]    eth_axi_awburst,
    output wire                              eth_axi_awlock,
    output wire [`AXI4_CACHE_WIDTH  -1:0]    eth_axi_awcache,
    output wire [`AXI4_PROT_WIDTH   -1:0]    eth_axi_awprot,
    output wire [`AXI4_QOS_WIDTH    -1:0]    eth_axi_awqos,
    output wire [`AXI4_REGION_WIDTH -1:0]    eth_axi_awregion,
    output wire [`AXI4_USER_WIDTH   -1:0]    eth_axi_awuser,
    output wire                              eth_axi_awvalid,
    input  wire                              eth_axi_awready,

    output wire  [`AXI4_ID_WIDTH     -1:0]    eth_axi_wid,
    output wire  [`AXI4_DATA_WIDTH   -1:0]    eth_axi_wdata,
    output wire  [`AXI4_STRB_WIDTH   -1:0]    eth_axi_wstrb,
    output wire                               eth_axi_wlast,
    output wire  [`AXI4_USER_WIDTH   -1:0]    eth_axi_wuser,
    output wire                               eth_axi_wvalid,
    input  wire                               eth_axi_wready,

    output wire  [`AXI4_ID_WIDTH     -1:0]    eth_axi_arid,
    output wire  [`AXI4_ADDR_WIDTH   -1:0]    eth_axi_araddr,
    output wire  [`AXI4_LEN_WIDTH    -1:0]    eth_axi_arlen,
    output wire  [`AXI4_SIZE_WIDTH   -1:0]    eth_axi_arsize,
    output wire  [`AXI4_BURST_WIDTH  -1:0]    eth_axi_arburst,
    output wire                               eth_axi_arlock,
    output wire  [`AXI4_CACHE_WIDTH  -1:0]    eth_axi_arcache,
    output wire  [`AXI4_PROT_WIDTH   -1:0]    eth_axi_arprot,
    output wire  [`AXI4_QOS_WIDTH    -1:0]    eth_axi_arqos,
    output wire  [`AXI4_REGION_WIDTH -1:0]    eth_axi_arregion,
    output wire  [`AXI4_USER_WIDTH   -1:0]    eth_axi_aruser,
    output wire                               eth_axi_arvalid,
    input  wire                               eth_axi_arready,

    input  wire  [`AXI4_ID_WIDTH     -1:0]    eth_axi_rid,
    input  wire  [`AXI4_DATA_WIDTH   -1:0]    eth_axi_rdata,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    eth_axi_rresp,
    input  wire                               eth_axi_rlast,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    eth_axi_ruser,
    input  wire                               eth_axi_rvalid,
    output wire                               eth_axi_rready,

    input  wire  [`AXI4_ID_WIDTH     -1:0]    eth_axi_bid,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    eth_axi_bresp,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    eth_axi_buser,
    input  wire                               eth_axi_bvalid,
    output wire                               eth_axi_bready, 
    `endif
    
	`ifdef MEEP_SRAM
	// Memory interchange space
	output wire [`AXI4_ID_WIDTH     -1:0]    sram_axi_awid,
    output wire [`AXI4_ADDR_WIDTH   -1:0]    sram_axi_awaddr,
    output wire [`AXI4_LEN_WIDTH    -1:0]    sram_axi_awlen,
    output wire [`AXI4_SIZE_WIDTH   -1:0]    sram_axi_awsize,
    output wire [`AXI4_BURST_WIDTH  -1:0]    sram_axi_awburst,
    output wire                              sram_axi_awlock,
    output wire [`AXI4_CACHE_WIDTH  -1:0]    sram_axi_awcache,
    output wire [`AXI4_PROT_WIDTH   -1:0]    sram_axi_awprot,
    output wire [`AXI4_QOS_WIDTH    -1:0]    sram_axi_awqos,
    output wire [`AXI4_REGION_WIDTH -1:0]    sram_axi_awregion,
    output wire [`AXI4_USER_WIDTH   -1:0]    sram_axi_awuser,
    output wire                              sram_axi_awvalid,
    input  wire                              sram_axi_awready,

    output wire  [`AXI4_ID_WIDTH     -1:0]    sram_axi_wid,
    output wire  [`AXI4_DATA_WIDTH   -1:0]    sram_axi_wdata,
    output wire  [`AXI4_STRB_WIDTH   -1:0]    sram_axi_wstrb,
    output wire                               sram_axi_wlast,
    output wire  [`AXI4_USER_WIDTH   -1:0]    sram_axi_wuser,
    output wire                               sram_axi_wvalid,
    input  wire                               sram_axi_wready,

    output wire  [`AXI4_ID_WIDTH     -1:0]    sram_axi_arid,
    output wire  [`AXI4_ADDR_WIDTH   -1:0]    sram_axi_araddr,
    output wire  [`AXI4_LEN_WIDTH    -1:0]    sram_axi_arlen,
    output wire  [`AXI4_SIZE_WIDTH   -1:0]    sram_axi_arsize,
    output wire  [`AXI4_BURST_WIDTH  -1:0]    sram_axi_arburst,
    output wire                               sram_axi_arlock,
    output wire  [`AXI4_CACHE_WIDTH  -1:0]    sram_axi_arcache,
    output wire  [`AXI4_PROT_WIDTH   -1:0]    sram_axi_arprot,
    output wire  [`AXI4_QOS_WIDTH    -1:0]    sram_axi_arqos,
    output wire  [`AXI4_REGION_WIDTH -1:0]    sram_axi_arregion,
    output wire  [`AXI4_USER_WIDTH   -1:0]    sram_axi_aruser,
    output wire                               sram_axi_arvalid,
    input  wire                               sram_axi_arready,

    input  wire  [`AXI4_ID_WIDTH     -1:0]    sram_axi_rid,
    input  wire  [`AXI4_DATA_WIDTH   -1:0]    sram_axi_rdata,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    sram_axi_rresp,
    input  wire                               sram_axi_rlast,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    sram_axi_ruser,
    input  wire                               sram_axi_rvalid,
    output wire                               sram_axi_rready,

    input  wire  [`AXI4_ID_WIDTH     -1:0]    sram_axi_bid,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    sram_axi_bresp,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    sram_axi_buser,
    input  wire                               sram_axi_bvalid,
    output wire                               sram_axi_bready,
    `endif
   
   `ifdef DEBUG_ROM 
    input                                    debug_rom_en,
    output                                   debug_rom_req,
    output  [63:0]                           debug_rom_addr,
    input   [63:0]                           debug_rom_rdata,
   `endif

   `ifdef PITON_NONCACH_MEM
	// non-cacheable system memory space
	input  wire                              ncmem_axi_aclk,
	input  wire                              ncmem_axi_arstn,
	
	output wire [`AXI4_ID_WIDTH     -1:0]    ncmem_axi_awid,
    output wire [`AXI4_ADDR_WIDTH   -1:0]    ncmem_axi_awaddr,
    output wire [`AXI4_LEN_WIDTH    -1:0]    ncmem_axi_awlen,
    output wire [`AXI4_SIZE_WIDTH   -1:0]    ncmem_axi_awsize,
    output wire [`AXI4_BURST_WIDTH  -1:0]    ncmem_axi_awburst,
    output wire                              ncmem_axi_awlock,
    output wire [`AXI4_CACHE_WIDTH  -1:0]    ncmem_axi_awcache,
    output wire [`AXI4_PROT_WIDTH   -1:0]    ncmem_axi_awprot,
    output wire [`AXI4_QOS_WIDTH    -1:0]    ncmem_axi_awqos,
    output wire [`AXI4_REGION_WIDTH -1:0]    ncmem_axi_awregion,
    output wire [`AXI4_USER_WIDTH   -1:0]    ncmem_axi_awuser,
    output wire                              ncmem_axi_awvalid,
    input  wire                              ncmem_axi_awready,

    output wire  [`AXI4_ID_WIDTH     -1:0]    ncmem_axi_wid,
    output wire  [`AXI4_DATA_WIDTH   -1:0]    ncmem_axi_wdata,
    output wire  [`AXI4_STRB_WIDTH   -1:0]    ncmem_axi_wstrb,
    output wire                               ncmem_axi_wlast,
    output wire  [`AXI4_USER_WIDTH   -1:0]    ncmem_axi_wuser,
    output wire                               ncmem_axi_wvalid,
    input  wire                               ncmem_axi_wready,

    output wire  [`AXI4_ID_WIDTH     -1:0]    ncmem_axi_arid,
    output wire  [`AXI4_ADDR_WIDTH   -1:0]    ncmem_axi_araddr,
    output wire  [`AXI4_LEN_WIDTH    -1:0]    ncmem_axi_arlen,
    output wire  [`AXI4_SIZE_WIDTH   -1:0]    ncmem_axi_arsize,
    output wire  [`AXI4_BURST_WIDTH  -1:0]    ncmem_axi_arburst,
    output wire                               ncmem_axi_arlock,
    output wire  [`AXI4_CACHE_WIDTH  -1:0]    ncmem_axi_arcache,
    output wire  [`AXI4_PROT_WIDTH   -1:0]    ncmem_axi_arprot,
    output wire  [`AXI4_QOS_WIDTH    -1:0]    ncmem_axi_arqos,
    output wire  [`AXI4_REGION_WIDTH -1:0]    ncmem_axi_arregion,
    output wire  [`AXI4_USER_WIDTH   -1:0]    ncmem_axi_aruser,
    output wire                               ncmem_axi_arvalid,
    input  wire                               ncmem_axi_arready,

    input  wire  [`AXI4_ID_WIDTH     -1:0]    ncmem_axi_rid,
    input  wire  [`AXI4_DATA_WIDTH   -1:0]    ncmem_axi_rdata,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    ncmem_axi_rresp,
    input  wire                               ncmem_axi_rlast,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    ncmem_axi_ruser,
    input  wire                               ncmem_axi_rvalid,
    output wire                               ncmem_axi_rready,

    input  wire  [`AXI4_ID_WIDTH     -1:0]    ncmem_axi_bid,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    ncmem_axi_bresp,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    ncmem_axi_buser,
    input  wire                               ncmem_axi_bvalid,
    output wire                               ncmem_axi_bready,
    `endif

    `ifdef PITON_EXTRA_MEMS
      // vectorized multi-MC AXI bus
      output [`PITON_EXTRA_MEMS * `AXI4_ID_WIDTH     -1:0]   mcx_axi_awid;
      output [`PITON_EXTRA_MEMS * `AXI4_ADDR_WIDTH   -1:0]   mcx_axi_awaddr;
      output [`PITON_EXTRA_MEMS * `AXI4_LEN_WIDTH    -1:0]   mcx_axi_awlen;
      output [`PITON_EXTRA_MEMS * `AXI4_SIZE_WIDTH   -1:0]   mcx_axi_awsize;
      output [`PITON_EXTRA_MEMS * `AXI4_BURST_WIDTH  -1:0]   mcx_axi_awburst;
      output [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_awlock;
      output [`PITON_EXTRA_MEMS * `AXI4_CACHE_WIDTH  -1:0]   mcx_axi_awcache;
      output [`PITON_EXTRA_MEMS * `AXI4_PROT_WIDTH   -1:0]   mcx_axi_awprot;
      output [`PITON_EXTRA_MEMS * `AXI4_QOS_WIDTH    -1:0]   mcx_axi_awqos;
      output [`PITON_EXTRA_MEMS * `AXI4_REGION_WIDTH -1:0]   mcx_axi_awregion;
      output [`PITON_EXTRA_MEMS * `AXI4_USER_WIDTH   -1:0]   mcx_axi_awuser;
      output [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_awvalid;
      input  [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_awready;

      output [`PITON_EXTRA_MEMS * `AXI4_ID_WIDTH     -1:0]   mcx_axi_wid;
      output [`PITON_EXTRA_MEMS * `AXI4_DATA_WIDTH   -1:0]   mcx_axi_wdata;
      output [`PITON_EXTRA_MEMS * `AXI4_STRB_WIDTH   -1:0]   mcx_axi_wstrb;
      output [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_wlast;
      output [`PITON_EXTRA_MEMS * `AXI4_USER_WIDTH   -1:0]   mcx_axi_wuser;
      output [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_wvalid;
      input  [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_wready;

      output [`PITON_EXTRA_MEMS * `AXI4_ID_WIDTH     -1:0]   mcx_axi_arid;
      output [`PITON_EXTRA_MEMS * `AXI4_ADDR_WIDTH   -1:0]   mcx_axi_araddr;
      output [`PITON_EXTRA_MEMS * `AXI4_LEN_WIDTH    -1:0]   mcx_axi_arlen;
      output [`PITON_EXTRA_MEMS * `AXI4_SIZE_WIDTH   -1:0]   mcx_axi_arsize;
      output [`PITON_EXTRA_MEMS * `AXI4_BURST_WIDTH  -1:0]   mcx_axi_arburst;
      output [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_arlock;
      output [`PITON_EXTRA_MEMS * `AXI4_CACHE_WIDTH  -1:0]   mcx_axi_arcache;
      output [`PITON_EXTRA_MEMS * `AXI4_PROT_WIDTH   -1:0]   mcx_axi_arprot;
      output [`PITON_EXTRA_MEMS * `AXI4_QOS_WIDTH    -1:0]   mcx_axi_arqos;
      output [`PITON_EXTRA_MEMS * `AXI4_REGION_WIDTH -1:0]   mcx_axi_arregion;
      output [`PITON_EXTRA_MEMS * `AXI4_USER_WIDTH   -1:0]   mcx_axi_aruser;
      output [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_arvalid;
      input  [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_arready;

      input  [`PITON_EXTRA_MEMS * `AXI4_ID_WIDTH     -1:0]   mcx_axi_rid;
      input  [`PITON_EXTRA_MEMS * `AXI4_DATA_WIDTH   -1:0]   mcx_axi_rdata;
      input  [`PITON_EXTRA_MEMS * `AXI4_RESP_WIDTH   -1:0]   mcx_axi_rresp;
      input  [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_rlast;
      input  [`PITON_EXTRA_MEMS * `AXI4_USER_WIDTH   -1:0]   mcx_axi_ruser;
      input  [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_rvalid;
      output [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_rready;

      input  [`PITON_EXTRA_MEMS * `AXI4_ID_WIDTH     -1:0]   mcx_axi_bid;
      input  [`PITON_EXTRA_MEMS * `AXI4_RESP_WIDTH   -1:0]   mcx_axi_bresp;
      input  [`PITON_EXTRA_MEMS * `AXI4_USER_WIDTH   -1:0]   mcx_axi_buser;
      input  [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_bvalid;
      output [`PITON_EXTRA_MEMS                      -1:0]   mcx_axi_bready;
    `endif //`ifdef PITON_EXTRA_MEMS

	// UART space
    output  [12:0]                          uart_axi_awaddr,        
    output                                  uart_axi_awvalid,
    input                                   uart_axi_awready,
    output  [31:0]                          uart_axi_wdata,
    output  [3:0 ]                          uart_axi_wstrb,
    output                                  uart_axi_wvalid,
    input                                   uart_axi_wready,
    input  [1:0]                            uart_axi_bresp,
    input                                   uart_axi_bvalid,
    output                                  uart_axi_bready,
    output  [12:0]                          uart_axi_araddr,
    output                                  uart_axi_arvalid,
    input                                   uart_axi_arready,
    input  [31:0]                           uart_axi_rdata,
    input  [1:0]                            uart_axi_rresp,
    input                                   uart_axi_rvalid,
    output                                  uart_axi_rready,
    input                                   uart_irq,

   `else //`ifdef PITONSYS_MEEP
      output                                    ddr_parity,
      output                                    hbm_cattrip,
   `endif //`ifdef PITONSYS_MEEP
`else
    inout [`DDR3_DM_WIDTH-1:0]                  ddr_dm,
`endif // XUPP3R_BOARD
`else // PITONSYS_DDR4
    output [`DDR3_DM_WIDTH-1:0]                 ddr_dm,
`endif // PITONSYS_DDR4
    output [`DDR3_ODT_WIDTH-1:0]                ddr_odt,
`else // ifndef F1_BOARD
    // AXI Write Address Channel Signals    
    input                                        mc_clk,
    output wire [`AXI4_ID_WIDTH     -1:0]    m_axi_awid,
    output wire [`AXI4_ADDR_WIDTH   -1:0]    m_axi_awaddr,
    output wire [`AXI4_LEN_WIDTH    -1:0]    m_axi_awlen,
    output wire [`AXI4_SIZE_WIDTH   -1:0]    m_axi_awsize,
    output wire [`AXI4_BURST_WIDTH  -1:0]    m_axi_awburst,
    output wire                                  m_axi_awlock,
    output wire [`AXI4_CACHE_WIDTH  -1:0]    m_axi_awcache,
    output wire [`AXI4_PROT_WIDTH   -1:0]    m_axi_awprot,
    output wire [`AXI4_QOS_WIDTH    -1:0]    m_axi_awqos,
    output wire [`AXI4_REGION_WIDTH -1:0]    m_axi_awregion,
    output wire [`AXI4_USER_WIDTH   -1:0]    m_axi_awuser,
    output wire                                  m_axi_awvalid,
    input  wire                                  m_axi_awready,

    // AXI Write Data Channel Signals
    output wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_wid,
    output wire  [`AXI4_DATA_WIDTH   -1:0]    m_axi_wdata,
    output wire  [`AXI4_STRB_WIDTH   -1:0]    m_axi_wstrb,
    output wire                                   m_axi_wlast,
    output wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_wuser,
    output wire                                   m_axi_wvalid,
    input  wire                                   m_axi_wready,

    // AXI Read Address Channel Signals
    output wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_arid,
    output wire  [`AXI4_ADDR_WIDTH   -1:0]    m_axi_araddr,
    output wire  [`AXI4_LEN_WIDTH    -1:0]    m_axi_arlen,
    output wire  [`AXI4_SIZE_WIDTH   -1:0]    m_axi_arsize,
    output wire  [`AXI4_BURST_WIDTH  -1:0]    m_axi_arburst,
    output wire                                   m_axi_arlock,
    output wire  [`AXI4_CACHE_WIDTH  -1:0]    m_axi_arcache,
    output wire  [`AXI4_PROT_WIDTH   -1:0]    m_axi_arprot,
    output wire  [`AXI4_QOS_WIDTH    -1:0]    m_axi_arqos,
    output wire  [`AXI4_REGION_WIDTH -1:0]    m_axi_arregion,
    output wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_aruser,
    output wire                                   m_axi_arvalid,
    input  wire                                   m_axi_arready,

    // AXI Read Data Channel Signals
    input  wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_rid,
    input  wire  [`AXI4_DATA_WIDTH   -1:0]    m_axi_rdata,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    m_axi_rresp,
    input  wire                                   m_axi_rlast,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_ruser,
    input  wire                                   m_axi_rvalid,
    output wire                                   m_axi_rready,

    // AXI Write Response Channel Signals
    input  wire  [`AXI4_ID_WIDTH     -1:0]    m_axi_bid,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    m_axi_bresp,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    m_axi_buser,
    input  wire                                   m_axi_bvalid,
    output wire                                   m_axi_bready, 

    input  wire                                   ddr_ready,
`endif // ifndef F1_BOARD
`endif // ifdef PITON_FPGA_MC_DDR3
`endif // endif PITONSYS_NO_MC

`ifdef PITONSYS_IOCTRL
`ifdef PITONSYS_UART
   `ifndef PITONSYS_MEEP
       input uart_rx,
       output uart_tx,
    `endif

`ifdef PITONSYS_UART_BOOT    
    input                                       uart_boot_en,
    input                                       uart_timeout_en,
    `ifdef ALVEOU280_BOARD
    
          input bootrom_linux_en,
    `endif // ALVEO
`endif // endif PITONSYS_UART_BOOT
`endif // endif PITONSYS_UART

`ifdef PITONSYS_SPI    
    input                                       sd_clk,
    input                                       sd_cd,
    output                                      sd_reset,
    output                                      sd_clk_out,
    inout                                       sd_cmd,
    inout   [3:0]                               sd_dat,
`endif // endif PITONSYS_SPI
`ifdef PITON_FPGA_ETHERNETLITE    
    input                                       net_axi_clk,
    output                                      net_phy_rst_n,

    input                                       net_phy_tx_clk,
    output                                      net_phy_tx_en,
    output  [3 : 0]                             net_phy_tx_data,

    input                                       net_phy_rx_clk,
    input                                       net_phy_dv,
    input  [3 : 0]                              net_phy_rx_data,
    input                                       net_phy_rx_er,

    inout                                       net_phy_mdio_io,
    output                                      net_phy_mdc,
`elsif PITON_FPGA_ETH_CMAC // PITON_FPGA_ETHERNETLITE    
    input          net_axi_clk,
    input          qsfp_ref_clk_n,
    input          qsfp_ref_clk_p,
    input   [3:0]  qsfp_4x_grx_n,
    input   [3:0]  qsfp_4x_grx_p,
    output  [3:0]  qsfp_4x_gtx_n,
    output  [3:0]  qsfp_4x_gtx_p,
`endif // PITON_FPGA_ETH_CMAC
`endif // endif PITONSYS_IOCTRL
`ifdef PITON_ARIANE    
    // Debug
    output                                      ndmreset_o,    // non-debug module reset
    output                                      dmactive_o,    // debug module is active
    output [`PITON_NUM_TILES-1:0]                     debug_req_o,   // async debug request
    input  [`PITON_NUM_TILES-1:0]                     unavailable_i, // communicate whether the hart is unavailable (e.g.: power down)
    // JTAG
    input                                       tck_i,
    input                                       tms_i,
    input                                       trst_ni,
    input                                       td_i,
    output                                      td_o,
    output                                      tdo_oe_o,
    // CLINT
    input                                       rtc_i,         // Real-time clock in (usually 32.768 kHz)
    output [`PITON_NUM_TILES-1:0]                     timer_irq_o,   // Timer interrupts
    output [`PITON_NUM_TILES-1:0]                     ipi_o,         // software interrupt (a.k.a inter-process-interrupt)
    // PLIC
    output [`PITON_NUM_TILES*2-1:0]                   irq_o          // level sensitive IR lines, mip & sip (async)
`endif
`ifdef PITON_LAGARTO 
    // Debug
    output                                      ndmreset_o,    // non-debug module reset
    output                                      dmactive_o,    // debug module is active
    output [`PITON_NUM_TILES-1:0]                     debug_req_o,   // async debug request
    input  [`PITON_NUM_TILES-1:0]                     unavailable_i, // communicate whether the hart is unavailable (e.g.: power down)
    // JTAG
    input                                       tck_i,
    input                                       tms_i,
    input                                       trst_ni,
    input                                       td_i,
    output                                      td_o,
    output                                      tdo_oe_o,
    // CLINT
    input                                       rtc_i,         // Real-time clock in (usually 32.768 kHz)
    output [`PITON_NUM_TILES-1:0]                     timer_irq_o,   // Timer interrupts
    output [`PITON_NUM_TILES-1:0]                     ipi_o,         // software interrupt (a.k.a inter-process-interrupt)
    // PLIC
    output [`PITON_NUM_TILES*2-1:0]                   irq_o,         // level sensitive IR lines, mip & sip (async)
    // PMU
    input [25*(`PITON_NUM_TILES)-1:0]                 pmu_sig_i,
    input                                       pmu_clk,
    input                                       vpu_clk
`endif
);

///////////////////////
// Type declarations //
///////////////////////
wire                                            mc_ui_clk_sync_rst;

reg                                             init_calib_complete_f;
reg                                             init_calib_complete_ff;

reg                                             io_ctrl_rst_n;

`ifndef PITONSYS_IOCTRL
wire                                            uart_boot_en;
wire                                            uart_timeout_en;
`else // ifdef PITONSYS_IOCTRL
`ifndef PITONSYS_UART
wire                                            uart_boot_en;
wire                                            uart_timeout_en;
`else // ifdef PITONSYS_UART
`ifndef PITONSYS_UART_BOOT
wire                                            uart_boot_en;
wire                                            uart_timeout_en;
`endif // endif PITONSYS_UART_BOOT
`endif // endif PITONSYS_UART
`endif // endif PITONSYS_IOCTRL

wire                                            cpu_mem_traffic;
wire                                            chip_filter_noc2_valid;
wire    [`NOC_DATA_WIDTH-1:0]                   chip_filter_noc2_data;
wire                                            filter_chip_noc2_ready;
wire                                            filter_chip_noc3_valid;
wire    [`NOC_DATA_WIDTH-1:0]                   filter_chip_noc3_data;
wire                                            chip_filter_noc3_ready;


wire                                            test_good_end;
wire                                            test_bad_end;
wire                                            mc_axi_deadlock;

<%
for i in range(len(devices)):
    if devices[i]["virtual"]:
            continue
# wires for the noc2 crossbar
    print("""
wire [`DATA_WIDTH-1:0] %s_buf_xbar_noc2_data;
wire                   %s_buf_xbar_noc2_valid;
wire                   %s_buf_xbar_noc2_yummy;
wire [`DATA_WIDTH-1:0] xbar_buf_%s_noc2_data;
wire                   xbar_buf_%s_noc2_valid;
wire                   xbar_buf_%s_noc2_yummy;

wire [`DATA_WIDTH-1:0] buf_%s_noc2_data;
wire                   buf_%s_noc2_valid;
wire                   %s_buf_noc2_ready;

wire [`DATA_WIDTH-1:0] %s_buf_noc2_data;
wire                   %s_buf_noc2_valid;
wire                   buf_%s_noc2_ready;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"]))

# wires for the noc3 crossbar
    print("""
wire [`DATA_WIDTH-1:0] %s_buf_xbar_noc3_data;
wire                   %s_buf_xbar_noc3_valid;
wire                   %s_buf_xbar_noc3_yummy;
wire [`DATA_WIDTH-1:0] xbar_buf_%s_noc3_data;
wire                   xbar_buf_%s_noc3_valid;
wire                   xbar_buf_%s_noc3_yummy;

wire [`DATA_WIDTH-1:0] buf_%s_noc3_data;
wire                   buf_%s_noc3_valid;
wire                   %s_buf_noc3_ready;

wire [`DATA_WIDTH-1:0] %s_buf_noc3_data;
wire                   %s_buf_noc3_valid;
wire                   buf_%s_noc3_ready;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"]))
    # if the device doesn't have a noc2 input, tie off unused wires
    if not (devices[i]["noc2_in"]):
        print("""
assign %s_buf_noc2_data = `DATA_WIDTH'b0;
assign %s_buf_noc2_valid = 1'b0;
assign %s_buf_noc3_ready = 1'b0;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"]))
    # otherwise, give it a set of packet filter wires except for the chip (for now)
    elif (i > 0):
        print("""
wire [`DATA_WIDTH-1:0]            %s_filter_noc2_data;
wire                              %s_filter_noc2_valid;
wire                              filter_%s_noc2_ready;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"]))
        print("""
wire [`DATA_WIDTH-1:0]             filter_%s_noc3_data;
wire                               filter_%s_noc3_valid;
wire                               %s_filter_noc3_ready;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"]))

%>

//////////////////////
// Sequential Logic //
//////////////////////

`ifdef PITONSYS_IOCTRL
`ifndef PITONSYS_NO_MC
`ifdef PITON_FPGA_MC_DDR3
always @ (posedge chipset_clk)
begin
    init_calib_complete_f <= init_calib_complete;
    init_calib_complete_ff <= init_calib_complete_f;
end
`endif // endif PITON_FPGA_MC_DDR3
`endif // endif PITONSYS_NO_MC
`endif // endif PITONSYS_IOCTRL

/////////////////////////
// Combinational Logic //
/////////////////////////

// Currently NoC 1 from chipset to interface is not used
// by any chipset implementation
assign chipset_intf_data_noc1 = {`NOC_DATA_WIDTH{1'b0}};
assign chipset_intf_val_noc1 = 1'b0;

// Currently NoC 3 from interface to chipset is not used
// by any chipset implementation
assign intf_chipset_rdy_noc3 = 1'b0;
assign chip_buf_noc3_valid = 1'b0;
assign chip_buf_noc3_data = {`NOC_DATA_WIDTH{1'b0}};

`ifdef PITONSYS_NO_MC
`ifndef PITON_FPGA_SYNTH
    // Tie off splitter memory interface
    assign mem_buf_noc2_ready = 1'b0;
    assign mem_buf_noc3_valid = 1'b0;
    assign mem_buf_noc3_data = {`NOC_DATA_WIDTH{1'b0}};
`endif // endif PITON_FPGA_SYNTH
`endif // endif PITONSYS_NO_MC


`ifdef PITONSYS_IOCTRL
    always @ *
    begin
    `ifndef PITONSYS_NO_MC
    `ifdef PITON_FPGA_MC_DDR3
        // Reset I/O ctrl as long as DRAM ctrl is not reset
        // and not calibrated or initialized
        io_ctrl_rst_n = ~mc_ui_clk_sync_rst & init_calib_complete_ff;
    `else // ifndef PITON_FPGA_MC_DDR3
        io_ctrl_rst_n = chipset_rst_n;
    `endif // endif PITON_FPGA_MC_DDR3
    `else // ifdef PITONSYS_NO_MC
        io_ctrl_rst_n = chipset_rst_n;
    `endif // PITONSYS_NO_MC
    end
`endif // endif PITONSYS_IOCTRL

`ifndef PITONSYS_IOCTRL
    assign uart_boot_en = 1'b0;
    assign uart_timeout_en = 1'b0;
`else // ifdef PITONSYS_IOCTRL
    `ifndef PITONSYS_UART
        assign uart_boot_en = 1'b0;
        assign uart_timeout_en = 1'b0;
    `else // ifdef PITONSYS_UART
        `ifndef PITONSYS_UART_BOOT
            assign uart_boot_en = 1'b0;
            assign uart_timeout_en = 1'b0;
        `endif // endif PITONSYS_UART_BOOT
    `endif // endif PITONSYS_UART
`endif // endif PITONSYS_IOCTRL

//////////////////////////
// Sub-module Instances //
//////////////////////////
`ifdef PITONSYS_IOCTRL
    assign cpu_mem_traffic = test_start | (~uart_boot_en);
`else
    assign cpu_mem_traffic = 1'b1;
`endif

assign chipset_intf_val_noc2 = buf_chip_noc2_valid;
assign chipset_intf_data_noc2 = buf_chip_noc2_data;
assign chip_buf_noc2_ready = chipset_intf_rdy_noc2;

assign chip_filter_noc2_valid = intf_chipset_val_noc2;
assign chip_filter_noc2_data = intf_chipset_data_noc2;
assign intf_chipset_rdy_noc2    = filter_chip_noc2_ready & cpu_mem_traffic;

// NoC 3
assign chipset_intf_val_noc3    = cpu_mem_traffic & filter_chip_noc3_valid;
assign chipset_intf_data_noc3   = filter_chip_noc3_data;

assign chip_filter_noc3_ready  = cpu_mem_traffic ? chipset_intf_rdy_noc3 : 1'b1;

`ifdef PITONSYS_UART_BOOT
test_end_checker test_end_checker(
    .clk                    (chipset_clk),
    .rst_n                  (chipset_rst_n),

    .src_checker_noc2_val   (chip_filter_noc2_valid),
    .src_checker_noc2_data  (chip_filter_noc2_data),
    .src_checker_noc2_rdy   (filter_chip_noc2_ready),

    .uart_boot_en           (uart_boot_en),
    .test_good_end          (test_good_end),
    .test_bad_end           (test_bad_end)
);
`else
    assign test_good_end = 1'b0;
    assign test_bad_end = 1'b0;
`endif

<%

# need to figure out number of invalid access signals
tmpNum=0
for i in range(len(devices)):
    if devices[i]["noc2_in"]:
        tmpNum +=1

if tmpNum:
    print("""
wire [%d-1:0] invalid_access;
assign invalid_access_o = |invalid_access;
""" % (tmpNum))
else:
    print("""
assign invalid_access_o = 1'b0;
""")

tmpIdx=0
for i in range(len(devices)):
    if devices[i]["noc2_in"]:
        print("""
packet_filter %s_packet_filter(
    .clk(chipset_clk),
    .rst_n(chipset_rst_n),
    // need to connect this to a LED
    .invalid_access_o(invalid_access[%d]),

    // noc2 to filter wires
    .noc2_filter_val(%s_filter_noc2_valid),
    .noc2_filter_data(%s_filter_noc2_data),
    .filter_noc2_rdy(filter_%s_noc2_ready),

    // filter to noc3 wires
    .filter_noc3_val(filter_%s_noc3_valid),
    .filter_noc3_data(filter_%s_noc3_data),
    .noc3_filter_rdy(%s_filter_noc3_ready),

    // filter to xbar wires
    .filter_xbar_val(%s_buf_noc2_valid),
    .filter_xbar_data(%s_buf_noc2_data),
    .xbar_filter_rdy(buf_%s_noc2_ready),

    // xbar to filter wires
    .xbar_filter_val(buf_%s_noc3_valid),
    .xbar_filter_data(buf_%s_noc3_data),
    .filter_xbar_rdy(%s_buf_noc3_ready),

    .uart_boot_en(uart_boot_en)
);
""" % (devices[i]["name"], tmpIdx,
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"]))
        tmpIdx+=1
%>

<%

xbartemplate = r'''
io_xbar_top_wrap io_xbar_noc2 (
    .clk                (chipset_clk),
    .reset_in           (~chipset_rst_n),

    .myChipID                   (14'b10000000000000),    // the first chip
    .myLocX                     (8'b0),  // not used
    .myLocY                     (8'b0),  // not used

'''

for i in range(len(devices)):
            if devices[i]["virtual"]:
                        continue
            xbartemplate += "    .dataIn_%d(%s_buf_xbar_noc2_data),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .validIn_%d(%s_buf_xbar_noc2_valid),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .yummyIn_%d(%s_buf_xbar_noc2_yummy),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .dataOut_%d(xbar_buf_%s_noc2_data),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .validOut_%d(xbar_buf_%s_noc2_valid),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .yummyOut_%d(xbar_buf_%s_noc2_yummy),\n\n" % (devices[i]["portnum"], devices[i]["name"])

xbartemplate = xbartemplate[:-3] + r'''
);'''

print(xbartemplate)

xbartemplate = r'''
io_xbar_top_wrap io_xbar_noc3 (
    .clk                (chipset_clk),
    .reset_in           (~chipset_rst_n),

    .myChipID                   (14'b10000000000000),    // the first chip
    .myLocX                     (8'b0),  // not used
    .myLocY                     (8'b0),  // not used

'''

for i in range(len(devices)):
            if devices[i]["virtual"]:
                        continue

            xbartemplate += "    .dataIn_%d(%s_buf_xbar_noc3_data),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .validIn_%d(%s_buf_xbar_noc3_valid),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .yummyIn_%d(%s_buf_xbar_noc3_yummy),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .dataOut_%d(xbar_buf_%s_noc3_data),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .validOut_%d(xbar_buf_%s_noc3_valid),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .yummyOut_%d(xbar_buf_%s_noc3_yummy),\n\n" % (devices[i]["portnum"], devices[i]["name"])

xbartemplate = xbartemplate[:-3] + r'''
    ,
    .thanksIn_%d()
);''' % (DYNAMIC_NODE_PORT - 1)


print(xbartemplate)

for i in range(len(devices)):
    if devices[i]["virtual"]:  
        continue

    valrdy_credit_template = r'''
valrdy_to_credit noc2_%s_to_xbar (
      .clk(chipset_clk),
      .reset(~chipset_rst_n),

      .data_in(%s_buf_noc2_data),
      .valid_in(%s_buf_noc2_valid),
      .ready_in(buf_%s_noc2_ready),

      .data_out(%s_buf_xbar_noc2_data),           // Data
      .valid_out(%s_buf_xbar_noc2_valid),       // Val signal
      .yummy_out(xbar_buf_%s_noc2_yummy)    // Yummy signal
);''' % (devices[i]["name"], devices[i]["name"], devices[i]["name"], devices[i]["name"],
        devices[i]["name"], devices[i]["name"], devices[i]["name"])

    credit_valrdy_template = r'''
credit_to_valrdy noc2_xbar_to_%s(
      .clk(chipset_clk),
      .reset(~chipset_rst_n),

      .data_in(xbar_buf_%s_noc2_data),
      .valid_in(xbar_buf_%s_noc2_valid),
      .yummy_in(%s_buf_xbar_noc2_yummy),

      .data_out(buf_%s_noc2_data),           // Data
      .valid_out(buf_%s_noc2_valid),       // Val signal from dynamic network to processor
      .ready_out(%s_buf_noc2_ready)    // Rdy signal from processor to dynamic network
);''' % (devices[i]["name"], devices[i]["name"], devices[i]["name"], devices[i]["name"],
         devices[i]["name"], devices[i]["name"], devices[i]["name"])

    print(valrdy_credit_template)
    print(credit_valrdy_template)

    valrdy_credit_template = r'''
valrdy_to_credit noc3_%s_to_xbar (
      .clk(chipset_clk),
      .reset(~chipset_rst_n),

      .data_in(%s_buf_noc3_data),
      .valid_in(%s_buf_noc3_valid),
      .ready_in(buf_%s_noc3_ready),

      .data_out(%s_buf_xbar_noc3_data),           // Data
      .valid_out(%s_buf_xbar_noc3_valid),       // Val signal
      .yummy_out(xbar_buf_%s_noc3_yummy)    // Yummy signal
);''' % (devices[i]["name"], devices[i]["name"], devices[i]["name"], devices[i]["name"],
        devices[i]["name"], devices[i]["name"], devices[i]["name"])

    credit_valrdy_template = r'''
credit_to_valrdy noc3_xbar_to_%s(
      .clk(chipset_clk),
      .reset(~chipset_rst_n),

      .data_in(xbar_buf_%s_noc3_data),
      .valid_in(xbar_buf_%s_noc3_valid),
      .yummy_in(%s_buf_xbar_noc3_yummy),

      .data_out(buf_%s_noc3_data),           // Data
      .valid_out(buf_%s_noc3_valid),       // Val signal from dynamic network to processor
      .ready_out(%s_buf_noc3_ready)    // Rdy signal from processor to dynamic network
);''' % (devices[i]["name"], devices[i]["name"], devices[i]["name"], devices[i]["name"],
         devices[i]["name"], devices[i]["name"], devices[i]["name"])

    print(valrdy_credit_template)
    print(credit_valrdy_template)
%>



`ifndef PITONSYS_NO_MC
// Memory controller.  Either uses "fake" simulated
// memory controller or FPGA memory controllers
`ifdef PITON_FPGA_MC_DDR3
    `ifdef F1_BOARD
        f1_mc_top mc_top(
            .sys_clk(chipset_clk),
            .sys_rst_n(chipset_rst_n),
            .mc_clk(mc_clk),

            .mc_flit_in_val(buf_mem_noc2_valid),
            .mc_flit_in_data(buf_mem_noc2_data),
            .mc_flit_in_rdy(mem_buf_noc2_ready),

            .mc_flit_out_val(mem_buf_noc3_valid),
            .mc_flit_out_data(mem_buf_noc3_data),
            .mc_flit_out_rdy(buf_mem_noc3_ready),

            .uart_boot_en(uart_boot_en),
            .init_calib_complete_out(init_calib_complete),
            .mc_ui_clk_sync_rst(mc_ui_clk_sync_rst),

            // AXI Write Address Channel Signals
            .m_axi_awid(m_axi_awid),
            .m_axi_awaddr(m_axi_awaddr),
            .m_axi_awlen(m_axi_awlen),
            .m_axi_awsize(m_axi_awsize),
            .m_axi_awburst(m_axi_awburst),
            .m_axi_awlock(m_axi_awlock),
            .m_axi_awcache(m_axi_awcache),
            .m_axi_awprot(m_axi_awprot),
            .m_axi_awqos(m_axi_awqos),
            .m_axi_awregion(m_axi_awregion),
            .m_axi_awuser(m_axi_awuser),
            .m_axi_awvalid(m_axi_awvalid),
            .m_axi_awready(m_axi_awready),

            // AXI Write Data Channel Signals
            .m_axi_wid(m_axi_wid),
            .m_axi_wdata(m_axi_wdata),
            .m_axi_wstrb(m_axi_wstrb),
            .m_axi_wlast(m_axi_wlast),
            .m_axi_wuser(m_axi_wuser),
            .m_axi_wvalid(m_axi_wvalid),
            .m_axi_wready(m_axi_wready),

            // AXI Read Address Channel Signals
            .m_axi_arid(m_axi_arid),
            .m_axi_araddr(m_axi_araddr),
            .m_axi_arlen(m_axi_arlen),
            .m_axi_arsize(m_axi_arsize),
            .m_axi_arburst(m_axi_arburst),
            .m_axi_arlock(m_axi_arlock),
            .m_axi_arcache(m_axi_arcache),
            .m_axi_arprot(m_axi_arprot),
            .m_axi_arqos(m_axi_arqos),
            .m_axi_arregion(m_axi_arregion),
            .m_axi_aruser(m_axi_aruser),
            .m_axi_arvalid(m_axi_arvalid),
            .m_axi_arready(m_axi_arready),

            // AXI Read Data Channel Signals
            .m_axi_rid(m_axi_rid),
            .m_axi_rdata(m_axi_rdata),
            .m_axi_rresp(m_axi_rresp),
            .m_axi_rlast(m_axi_rlast),
            .m_axi_ruser(m_axi_ruser),
            .m_axi_rvalid(m_axi_rvalid),
            .m_axi_rready(m_axi_rready),

            // AXI Write Response Channel Signals
            .m_axi_bid(m_axi_bid),
            .m_axi_bresp(m_axi_bresp),
            .m_axi_buser(m_axi_buser),
            .m_axi_bvalid(m_axi_bvalid),
            .m_axi_bready(m_axi_bready), 
            .ddr_ready(ddr_ready)
        );
    `else
        mc_top mc_top(
            .mc_ui_clk_sync_rst(mc_ui_clk_sync_rst),

            .core_ref_clk(chipset_clk),
            .sys_rst_n(chipset_rst_n),

            .mc_flit_in_val(buf_mem_noc2_valid),
            .mc_flit_in_data(buf_mem_noc2_data),
            .mc_flit_in_rdy(mem_buf_noc2_ready),

            .mc_flit_out_val(mem_buf_noc3_valid),
            .mc_flit_out_data(mem_buf_noc3_data),
            .mc_flit_out_rdy(buf_mem_noc3_ready),

          `ifdef PITON_EXTRA_MEMS
            .mcx_flit_in_val (intf_mcx_val_noc2 ),
            .mcx_flit_in_data(intf_mcx_data_noc2),
            .mcx_flit_in_rdy (intf_mcx_rdy_noc2 ),

            .mcx_flit_out_val (mcx_intf_val_noc3 ),
            .mcx_flit_out_data(mcx_intf_data_noc3),
            .mcx_flit_out_rdy (mcx_intf_rdy_noc3 ),
           `endif

            .uart_boot_en(uart_boot_en),
            .init_calib_complete_out(init_calib_complete),
            .mc_axi_deadlock(mc_axi_deadlock),

        `ifdef PITONSYS_DDR4
           `ifndef PITONSYS_MEEP
            .sys_clk_p(mc_clk_p),
            .sys_clk_n(mc_clk_n),
            .ddr_act_n(ddr_act_n),
            .ddr_bg(ddr_bg),
           `else
            .mc_clk(mc_clk),
           `endif
        `ifdef PITONSYS_PCIE
            .pci_express_x16_rxn(pci_express_x16_rxn),
            .pci_express_x16_rxp(pci_express_x16_rxp),
            .pci_express_x16_txn(pci_express_x16_txn),
            .pci_express_x16_txp(pci_express_x16_txp),
            .pcie_gpio(pcie_gpio),
            .pcie_perstn(pcie_perstn),
            .pcie_refclk_n(pcie_refclk_n),
            .pcie_refclk_p(pcie_refclk_p),
        `endif
        `else // PITONSYS_DDR4
            .sys_clk(mc_clk),
            .ddr_cas_n(ddr_cas_n),
            .ddr_ras_n(ddr_ras_n),
            .ddr_we_n(ddr_we_n),
        `endif // PITONSYS_DDR4

        `ifdef PITONSYS_MC_SRAM
           .sram_flit_in_data(buf_sram_noc2_data),
           .sram_flit_in_val(buf_sram_noc2_valid),
           .sram_flit_in_rdy(sram_buf_noc2_ready),

           .sram_flit_out_data(sram_buf_noc3_data),
           .sram_flit_out_val(sram_buf_noc3_valid),
           .sram_flit_out_rdy(buf_sram_noc3_ready),
        `endif // PITONSYS_MC_SRAM

            .ddr_addr(ddr_addr),
            .ddr_ba(ddr_ba),
            .ddr_ck_n(ddr_ck_n),
            .ddr_ck_p(ddr_ck_p),
            .ddr_cke(ddr_cke),
            .ddr_reset_n(ddr_reset_n),
            .ddr_dq(ddr_dq),
            .ddr_dqs_n(ddr_dqs_n),
            .ddr_dqs_p(ddr_dqs_p),
        `ifndef NEXYSVIDEO_BOARD
            .ddr_cs_n(ddr_cs_n),
        `endif // endif NEXYSVIDEO_BOARD
        `ifdef XUPP3R_BOARD
            .ddr_parity(ddr_parity),
        `elsif ALVEOU280_BOARD
          `ifdef PITONSYS_MEEP
            
            .init_calib_complete (hbm_calib_complete),
            
            .m_axi_awid      (m_axi_awid     ),
            .m_axi_awaddr    (m_axi_awaddr   ),
            .m_axi_awlen     (m_axi_awlen    ),
            .m_axi_awsize    (m_axi_awsize   ),
            .m_axi_awburst   (m_axi_awburst  ),
            .m_axi_awlock    (m_axi_awlock   ),
            .m_axi_awcache   (m_axi_awcache  ),
            .m_axi_awprot    (m_axi_awprot   ),
            .m_axi_awqos     (m_axi_awqos    ),
            .m_axi_awregion  (m_axi_awregion ),
            .m_axi_awuser    (m_axi_awuser   ),
            .m_axi_awvalid   (m_axi_awvalid  ),
            .m_axi_awready   (m_axi_awready  ),
            
            .m_axi_wid       (m_axi_wid      ),
            .m_axi_wdata     (m_axi_wdata    ),
            .m_axi_wstrb     (m_axi_wstrb    ),
            .m_axi_wlast     (m_axi_wlast    ),
            .m_axi_wuser     (m_axi_wuser    ),
            .m_axi_wvalid    (m_axi_wvalid   ),
            .m_axi_wready    (m_axi_wready   ),
            
            .m_axi_arid      (m_axi_arid     ),
            .m_axi_araddr    (m_axi_araddr   ),
            .m_axi_arlen     (m_axi_arlen    ),
            .m_axi_arsize    (m_axi_arsize   ),
            .m_axi_arburst   (m_axi_arburst  ),
            .m_axi_arlock    (m_axi_arlock   ),
            .m_axi_arcache   (m_axi_arcache  ),
            .m_axi_arprot    (m_axi_arprot   ),
            .m_axi_arqos     (m_axi_arqos    ),
            .m_axi_arregion  (m_axi_arregion ),
            .m_axi_aruser    (m_axi_aruser   ),
            .m_axi_arvalid   (m_axi_arvalid  ),
            .m_axi_arready   (m_axi_arready  ),
            
            .m_axi_rid       (m_axi_rid      ),
            .m_axi_rdata     (m_axi_rdata    ),
            .m_axi_rresp     (m_axi_rresp    ),
            .m_axi_rlast     (m_axi_rlast    ),
            .m_axi_ruser     (m_axi_ruser    ),
            .m_axi_rvalid    (m_axi_rvalid   ),
            .m_axi_rready    (m_axi_rready   ),
            
            .m_axi_bid       (m_axi_bid      ),
            .m_axi_bresp     (m_axi_bresp    ),
            .m_axi_buser     (m_axi_buser    ),
            .m_axi_bvalid    (m_axi_bvalid   ),
            .m_axi_bready    (m_axi_bready   ),

            `ifdef PITON_EXTRA_MEMS
             // vectorized multi-MC AXI bus
            .mcx_axi_awid      (mcx_axi_awid     ),
            .mcx_axi_awaddr    (mcx_axi_awaddr   ),
            .mcx_axi_awlen     (mcx_axi_awlen    ),
            .mcx_axi_awsize    (mcx_axi_awsize   ),
            .mcx_axi_awburst   (mcx_axi_awburst  ),
            .mcx_axi_awlock    (mcx_axi_awlock   ),
            .mcx_axi_awcache   (mcx_axi_awcache  ),
            .mcx_axi_awprot    (mcx_axi_awprot   ),
            .mcx_axi_awqos     (mcx_axi_awqos    ),
            .mcx_axi_awregion  (mcx_axi_awregion ),
            .mcx_axi_awuser    (mcx_axi_awuser   ),
            .mcx_axi_awvalid   (mcx_axi_awvalid  ),
            .mcx_axi_awready   (mcx_axi_awready  ),
            
            .mcx_axi_wid       (mcx_axi_wid      ),
            .mcx_axi_wdata     (mcx_axi_wdata    ),
            .mcx_axi_wstrb     (mcx_axi_wstrb    ),
            .mcx_axi_wlast     (mcx_axi_wlast    ),
            .mcx_axi_wuser     (mcx_axi_wuser    ),
            .mcx_axi_wvalid    (mcx_axi_wvalid   ),
            .mcx_axi_wready    (mcx_axi_wready   ),
            
            .mcx_axi_arid      (mcx_axi_arid     ),
            .mcx_axi_araddr    (mcx_axi_araddr   ),
            .mcx_axi_arlen     (mcx_axi_arlen    ),
            .mcx_axi_arsize    (mcx_axi_arsize   ),
            .mcx_axi_arburst   (mcx_axi_arburst  ),
            .mcx_axi_arlock    (mcx_axi_arlock   ),
            .mcx_axi_arcache   (mcx_axi_arcache  ),
            .mcx_axi_arprot    (mcx_axi_arprot   ),
            .mcx_axi_arqos     (mcx_axi_arqos    ),
            .mcx_axi_arregion  (mcx_axi_arregion ),
            .mcx_axi_aruser    (mcx_axi_aruser   ),
            .mcx_axi_arvalid   (mcx_axi_arvalid  ),
            .mcx_axi_arready   (mcx_axi_arready  ),
            
            .mcx_axi_rid       (mcx_axi_rid      ),
            .mcx_axi_rdata     (mcx_axi_rdata    ),
            .mcx_axi_rresp     (mcx_axi_rresp    ),
            .mcx_axi_rlast     (mcx_axi_rlast    ),
            .mcx_axi_ruser     (mcx_axi_ruser    ),
            .mcx_axi_rvalid    (mcx_axi_rvalid   ),
            .mcx_axi_rready    (mcx_axi_rready   ),
            
            .mcx_axi_bid       (mcx_axi_bid      ),
            .mcx_axi_bresp     (mcx_axi_bresp    ),
            .mcx_axi_buser     (mcx_axi_buser    ),
            .mcx_axi_bvalid    (mcx_axi_bvalid   ),
            .mcx_axi_bready    (mcx_axi_bready   ),
            `endif

          `else //`ifdef PITONSYS_MEEP
            .ddr_parity(ddr_parity),
            .hbm_cattrip(hbm_cattrip),       
          `endif //`ifdef PITONSYS_MEEP
        `else
            .ddr_dm(ddr_dm),
        `endif // XUPP3R_BOARD
            .ddr_odt(ddr_odt)
        );
    `endif // F1_BOARD

`else

`include "cross_module.tmp.h"


// Fake Memory Controller
fake_mem_ctrl fake_mem_ctrl(
    .clk                ( chipset_clk        ),
    .rst_n              ( chipset_rst_n      ),
    .noc_valid_in       ( buf_mem_noc2_valid ),
    .noc_data_in        ( buf_mem_noc2_data  ),
    .noc_ready_in       ( mem_buf_noc2_ready ),
    .noc_valid_out      ( mem_buf_noc3_valid ),
    .noc_data_out       ( mem_buf_noc3_data  ),
    .noc_ready_out      ( buf_mem_noc3_ready )
);

`ifdef PITON_EXTRA_MEMS
genvar i;
generate
for(i=0;i<`PITON_EXTRA_MEMS;i=i+1) begin: MC_
   fake_mem_ctrl #(
    .HMB_CHAN_NUM(i)
   ) fake_mc ( 
    .clk                ( chipset_clk        ), 
    .rst_n              ( chipset_rst_n      ), 
    .noc_valid_in       ( intf_mcx_val_noc2 [i] ), 
    .noc_data_in        ( intf_mcx_data_noc2[i * `NOC_DATA_WIDTH +: `NOC_DATA_WIDTH]  ), 
    .noc_ready_in       ( intf_mcx_rdy_noc2 [i] ), 
    .noc_valid_out      ( mcx_intf_val_noc3 [i] ), 
    .noc_data_out       ( mcx_intf_data_noc3[i * `NOC_DATA_WIDTH +: `NOC_DATA_WIDTH]  ), 
    .noc_ready_out      ( mcx_intf_rdy_noc3 [i] ) 
	); 
end
endgenerate
`endif


// Just instantiating SRAM part of whole MC
`ifdef PITONSYS_MC_SRAM
    mc_top mc_top(
      .core_ref_clk(chipset_clk),
      .sys_rst_n(chipset_rst_n),
      .mc_axi_deadlock(mc_axi_deadlock),

      .sram_flit_in_data(buf_sram_noc2_data),
      .sram_flit_in_val(buf_sram_noc2_valid),
      .sram_flit_in_rdy(sram_buf_noc2_ready),

      .sram_flit_out_data(sram_buf_noc3_data),
      .sram_flit_out_val(sram_buf_noc3_valid),
      .sram_flit_out_rdy(buf_sram_noc3_ready)
    );
`else
    assign mc_axi_deadlock = 1'b0;
`endif // endif PITONSYS_MC_SRAM

`endif // endif PITON_FPGA_MC_DDR3

`else

`ifdef PITON_FPGA_BRAM_TEST

    fake_boot_ctrl  fake_boot_ctrl(
        .clk            ( chipset_clk        ),
        .rst_n          ( chipset_rst_n      ),

        .noc_valid_in   ( buf_mem_noc2_valid ),
        .noc_data_in    ( buf_mem_noc2_data  ),
        .noc_ready_in   ( mem_buf_noc2_ready ),

        .noc_valid_out  ( mem_buf_noc3_valid ),
        .noc_data_out   ( mem_buf_noc3_data  ),
        .noc_ready_out  ( buf_mem_noc3_ready )
    );

`elsif PITON_FPGA_BRAM_BOOT

    fake_boot_ctrl  fake_boot_ctrl(
        .clk            ( chipset_clk        ),
        .rst_n          ( chipset_rst_n      ),

        .noc_valid_in   ( buf_mem_noc2_valid ),
        .noc_data_in    ( buf_mem_noc2_data  ),
        .noc_ready_in   ( mem_buf_noc2_ready ),

        .noc_valid_out  ( mem_buf_noc3_valid ),
        .noc_data_out   ( mem_buf_noc3_data  ),
        .noc_ready_out  ( buf_mem_noc3_ready )
    );

`endif

`endif // endif PITONSYS_NO_MC

 `ifdef PITONSYS_MEEP
   localparam integer NUM_INTR_ETH = 2;
 `elsif PITON_FPGA_ETH_CMAC
   localparam integer NUM_INTR_ETH = 2;
 `else
   localparam integer NUM_INTR_ETH = 1;
 `endif

localparam integer NUM_INTR_UART  = 1;
localparam integer NUM_INTR_RISCV = NUM_INTR_ETH + NUM_INTR_UART;


wire                    uart_interrupt;
wire [NUM_INTR_ETH-1:0] net_interrupt;


`ifdef PITONSYS_IOCTRL

wire ciop_iob_rst_n;
assign ciop_iob_rst_n = io_ctrl_rst_n & test_start & ~piton_ready_n;

ciop_iob ciop_iob     (
    .chip_clk        ( chipset_clk           ),
    .fpga_clk        ( chipset_clk           ),
    .rst_n           ( ciop_iob_rst_n        ),

    .noc1_in_val     ( intf_chipset_val_noc1 ),
    .noc1_in_data    ( intf_chipset_data_noc1),
    .noc1_in_rdy     ( intf_chipset_rdy_noc1 ),

    .noc2_out_val    ( iob_filter_noc2_valid ),
    .noc2_out_data   ( iob_filter_noc2_data  ),
    .noc2_out_rdy    ( filter_iob_noc2_ready ),

    .noc3_in_val     ( filter_iob_noc3_valid ),
    .noc3_in_data    ( filter_iob_noc3_data  ),
    .noc3_in_rdy     ( iob_filter_noc3_ready ),

    .noc2_in_val     ( buf_iob_noc2_valid    ),
    .noc2_in_data    ( buf_iob_noc2_data     ),
    .noc2_in_rdy     ( iob_buf_noc2_ready    ),

    .noc3_out_val    ( iob_buf_noc3_valid    ),
    .noc3_out_data   ( iob_buf_noc3_data     ),
    .noc3_out_rdy    ( buf_iob_noc3_ready    ),

    .uart_interrupt ( uart_interrupt         ),
    .net_interrupt  ( net_interrupt          )
);


`ifdef PITONSYS_UART
<%
for i in range(1, len(devices)):
    if devices[i]["name"] == "uart":
        print('''
uart_top        uart_top (
    .axi_clk                    ( chipset_clk                           ),
    .rst_n                      ( chipset_rst_n                         ),

    `ifdef PITONSYS_MEEP
    
      .uart_axi_awaddr(uart_axi_awaddr),
      .uart_axi_awvalid(uart_axi_awvalid),
      .uart_axi_awready(uart_axi_awready),
      .uart_axi_wdata(uart_axi_wdata),
      .uart_axi_wstrb(uart_axi_wstrb),
      .uart_axi_wvalid(uart_axi_wvalid),
      .uart_axi_wready(uart_axi_wready),
      .uart_axi_bresp(uart_axi_bresp),
      .uart_axi_bvalid(uart_axi_bvalid),
      .uart_axi_bready(uart_axi_bready),
      .uart_axi_araddr(uart_axi_araddr),
      .uart_axi_arvalid(uart_axi_arvalid),
      .uart_axi_arready(uart_axi_arready),
      .uart_axi_rdata(uart_axi_rdata),
      .uart_axi_rresp(uart_axi_rresp),
      .uart_axi_rvalid(uart_axi_rvalid),
      .uart_axi_rready(uart_axi_rready),
    `else
    .uart_tx                    ( uart_tx                               ),
    .uart_rx                    ( uart_rx                               ),  
    .uart_interrupt             ( uart_interrupt                        ),
    `endif

`ifdef PITONSYS_UART_LOOBACK
    // Can be used to loobpack UART for testing
    .uart_lb_sw                 ( 1'b1                                  ),
`else // ifndef PITONSYS_UART_LOOBACK
    .uart_lb_sw                 ( 1'b0                                  ),
`endif // endif PITONSYS_UART_LOOBACK

`ifdef PITONSYS_PCIE
    .uart_boot_en               ( pcie_gpio[4]                          ), //uart_boot_en
`else // PITONSYS_PCIE
    .uart_boot_en               ( uart_boot_en                          ),
`endif // PITONSYS_PCIE
`ifndef PITONSYS_NO_MC
`ifdef PITON_FPGA_MC_DDR3
    .init_calib_complete        (init_calib_complete_ff                 ),
`else // PITON_FPGA_MC_DDR3
    .init_calib_complete        (1'b1                                   ),
`endif //PITON_FPGA_MC_DDR3
`else // PITONSYS_NO_MC
    .init_calib_complete        (1'b1                                   ),
`endif // PITONSYS_NO_MC

    // Uncomment to connect to the switch
    .uart_timeout_en(uart_timeout_en),
    //.uart_timeout_en            ( 1'b1                                  ),

    .test_start                 ( test_start                            ),
    .test_good_end              ( test_good_end                         ),
    .test_bad_end               ( test_bad_end                          ),
    .mc_axi_deadlock            ( mc_axi_deadlock                       ),
    .uart_rst_out_n             ( uart_rst_out_n                        ),

    .chip_id                    ( {1'b1, {(`NOC_CHIPID_WIDTH-1){1'b0}}} ),
    .x_id                       ( `NOC_X_WIDTH'd%s                      ),
    .y_id                       ( `NOC_Y_WIDTH'd0                       ),
    // input from noc2
    .xbar_uart_noc2_valid       ( buf_uart_noc2_valid                   ),
    .xbar_uart_noc2_data        ( buf_uart_noc2_data                    ),
    .uart_xbar_noc2_ready       ( uart_buf_noc2_ready                   ),

    //output to noc3
    .uart_xbar_noc3_valid       ( uart_buf_noc3_valid                   ),
    .uart_xbar_noc3_data        ( uart_buf_noc3_data                    ),
    .xbar_uart_noc3_ready       ( buf_uart_noc3_ready                   ),

    // output to noc2
    .uart_xbar_noc2_valid       ( uart_filter_noc2_valid                ),
    .uart_xbar_noc2_data        ( uart_filter_noc2_data                 ),
    .xbar_uart_noc2_ready       ( filter_uart_noc2_ready                ),

    // input from noc3
    .xbar_uart_noc3_valid       ( filter_uart_noc3_valid                ),
    .xbar_uart_noc3_data        ( filter_uart_noc3_data                 ),
    .uart_xbar_noc3_ready       ( uart_filter_noc3_ready                )
);''' % (devices[i]["portnum"]))
%>
`else // ifndef PITONSYS_UART
    assign uart_interrupt = 1'b0;
    assign test_start = 1'b1;
`endif // endif PITONSYS_UART

// SPI interface
`ifdef PITONSYS_SPI
`ifdef PITON_FPGA_SD_BOOT

    /* Bridge between NOCs and SD Card */
    piton_sd_top piton_sd_top (
        .sys_clk          ( chipset_clk       ),
        .sd_clk           ( sd_clk            ),
        .sys_rst          ( ~chipset_rst_n    ),

        .splitter_sd_val  ( buf_sd_noc2_valid ),
        .splitter_sd_data ( buf_sd_noc2_data  ),
        .sd_splitter_rdy  ( sd_buf_noc2_ready ),

        .sd_splitter_val  ( sd_buf_noc3_valid ),
        .sd_splitter_data ( sd_buf_noc3_data  ),
        .splitter_sd_rdy  ( buf_sd_noc3_ready ),

        .sd_cd            ( sd_cd             ),
        .sd_reset         ( sd_reset          ),
        .sd_clk_out       ( sd_clk_out        ),
        .sd_cmd           ( sd_cmd            ),
        .sd_dat           ( sd_dat            )
        );

`endif
`endif


`ifdef PITON_FPGA_ETH


    eth_top #(
    `ifdef PITON_ARIANE
      .SWAP_ENDIANESS(1),
    `elsif PITON_LAGARTO
      .SWAP_ENDIANESS(1),
    `else
      .SWAP_ENDIANESS(0),
    `endif
      .NUM_INTR(NUM_INTR_ETH)
    ) eth_top (
        .chipset_clk     ( chipset_clk        ),
        .rst_n           ( chipset_rst_n      ),

		// Interrupts are forwarded in the chipset_clk domain
        .net_interrupt   ( net_interrupt      ),

        .noc_in_val      ( buf_net_noc2_valid ),
        .noc_in_data     ( buf_net_noc2_data  ),
        .noc_in_rdy      ( net_buf_noc2_ready ),

        .noc_out_val     ( net_buf_noc3_valid ),
        .noc_out_data    ( net_buf_noc3_data  ),
        .noc_out_rdy     ( buf_net_noc3_ready )
		
		// Common inputs for all cases 	

    `ifdef PITON_FPGA_ETHERNETLITE
        ,
        .net_phy_rst_n   ( net_phy_rst_n      ),

        .net_phy_tx_clk  ( net_phy_tx_clk     ),
        .net_phy_tx_en   ( net_phy_tx_en      ),
        .net_phy_tx_data ( net_phy_tx_data    ),

        .net_phy_rx_clk  ( net_phy_rx_clk     ),
        .net_phy_dv      ( net_phy_dv         ),
        .net_phy_rx_data ( net_phy_rx_data    ),
        .net_phy_rx_er   ( net_phy_rx_er      ),

        .net_phy_mdio_io ( net_phy_mdio_io    ),
        .net_phy_mdc     ( net_phy_mdc        )
    `elsif PITON_FPGA_ETH_CMAC // PITON_FPGA_ETHERNETLITE        
        ,
        `ifndef PITONSYS_MEEP
        .qsfp_ref_clk_n  (qsfp_ref_clk_n),
        .qsfp_ref_clk_p  (qsfp_ref_clk_p),
        .qsfp_4x_grx_n   (qsfp_4x_grx_n),
        .qsfp_4x_grx_p   (qsfp_4x_grx_p),
        .qsfp_4x_gtx_n   (qsfp_4x_gtx_n),
        .qsfp_4x_gtx_p   (qsfp_4x_gtx_p)
        `else		
		// in PITONSYS_MEEP the CLK, RST, and interrupts are inputs to this core
		.net_axi_clk        (eth_axi_aclk   ),		
		.net_axi_arstn      (eth_axi_arstn  ),		
		.net_axi_intr       (eth_irq        ),
        `ifdef ETHERNET_DMA
           .dma_s_axi_awaddr   (dma_s_axi_awaddr ) ,
           .dma_s_axi_awvalid  (dma_s_axi_awvalid) ,
           .dma_s_axi_awready  (dma_s_axi_awready) ,

           .dma_s_axi_wdata    (dma_s_axi_wdata  ) ,
           .dma_s_axi_wstrb    (dma_s_axi_wstrb  ) ,
           .dma_s_axi_wvalid   (dma_s_axi_wvalid ) ,
           .dma_s_axi_wready   (dma_s_axi_wready ) ,

           .dma_s_axi_bresp    (dma_s_axi_bresp  ) ,
           .dma_s_axi_bvalid   (dma_s_axi_bvalid ) ,
           .dma_s_axi_bready   (dma_s_axi_bready ) ,

           .dma_s_axi_araddr   (dma_s_axi_araddr ) ,
           .dma_s_axi_arvalid  (dma_s_axi_arvalid) ,
           .dma_s_axi_arready  (dma_s_axi_arready) ,

           .dma_s_axi_rdata    (dma_s_axi_rdata  ) ,
           .dma_s_axi_rresp    (dma_s_axi_rresp  ) ,
           .dma_s_axi_rvalid   (dma_s_axi_rvalid ) ,
           .dma_s_axi_rready   (dma_s_axi_rready ) 
        `else
        .core_axi_awid      (eth_axi_awid   ),
        .core_axi_awaddr    (eth_axi_awaddr ),
        .core_axi_awlen     (eth_axi_awlen  ),
        .core_axi_awsize    (eth_axi_awsize ),
        .core_axi_awburst   (eth_axi_awburst),
        .core_axi_awlock    (eth_axi_awlock ),
        .core_axi_awcache   (eth_axi_awcache),
        .core_axi_awprot    (eth_axi_awprot ),
        .core_axi_awqos     (eth_axi_awqos  ),
        .core_axi_awregion  (eth_axi_awregion),
        .core_axi_awuser    (eth_axi_awuser ),
        .core_axi_awvalid   (eth_axi_awvalid ),
        .core_axi_awready   (eth_axi_awready ),
                            
        .core_axi_wid       (eth_axi_wid   ),
        .core_axi_wdata     (eth_axi_wdata ),
        .core_axi_wstrb     (eth_axi_wstrb ),
        .core_axi_wlast     (eth_axi_wlast ),
        .core_axi_wuser     (eth_axi_wuser ),
        .core_axi_wvalid    (eth_axi_wvalid),
        .core_axi_wready    (eth_axi_wready),
                            
        .core_axi_arid      (eth_axi_arid  ),
        .core_axi_araddr    (eth_axi_araddr),
        .core_axi_arlen     (eth_axi_arlen ),
        .core_axi_arsize    (eth_axi_arsize),
        .core_axi_arburst   (eth_axi_arburst ),
        .core_axi_arlock    (eth_axi_arlock  ),
        .core_axi_arcache   (eth_axi_arcache ),
        .core_axi_arprot    (eth_axi_arprot  ),
        .core_axi_arqos     (eth_axi_arqos   ),
        .core_axi_arregion  (eth_axi_arregion),
        .core_axi_aruser    (eth_axi_aruser  ),
        .core_axi_arvalid   (eth_axi_arvalid ),
        .core_axi_arready   (eth_axi_arready ),
                            
        .core_axi_rid       (eth_axi_rid   ),
        .core_axi_rdata     (eth_axi_rdata ),
        .core_axi_rresp     (eth_axi_rresp ),
        .core_axi_rlast     (eth_axi_rlast ),
        .core_axi_ruser     (eth_axi_ruser ),
        .core_axi_rvalid    (eth_axi_rvalid ),
        .core_axi_rready    (eth_axi_rready ),
                            
        .core_axi_bid       (eth_axi_bid    ),
        .core_axi_bresp     (eth_axi_bresp  ),
        .core_axi_buser     (eth_axi_buser  ),
        .core_axi_bvalid    (eth_axi_bvalid ),
        .core_axi_bready    (eth_axi_bready )		
        `endif // ETHERNET_DMA
        `endif // PITONSYS_MEEP
    `endif // PITON_FPGA_ETH_CMAC
    );
`endif // PITON_FPGA_ETH

`else // PITONSYS_IOCTRL

assign net_interrupt  = 1'b0;
assign uart_interrupt = 1'b0;

// Fake iobridge
// Tie noc1 input low because it's unused
assign intf_chipset_rdy_noc1 = 1'b0;
ciop_fake_iob ciop_fake_iob(
    .noc_out_val       ( iob_filter_noc2_valid ),
    .noc_out_rdy       ( filter_iob_noc2_ready ),
    .noc_out_data      ( iob_filter_noc2_data  ),

    <%
        text = r'''
        .spc0_inst_done    (`PITON_CORE0_INST_DONE),
        .pc_w0             (`PITON_CORE0_PC_W0),
        '''

        for i in range (PITON_NUM_TILES):
            text2 = text;
            text2 = text2.replace("PITON_CORE0", "PITON_CORE" + repr(i));
            text2 = text2.replace("spc0_inst_done", "spc" + repr(i) + "_inst_done");
            text2 = text2.replace("pc_w0", "pc_w" + repr(i));
            text2 = text2.replace("PC_W0", "PC_W" + repr(i));
            print(text2)
    %>
    .clk               (chipset_clk),
    .rst_n             (chipset_rst_n)
//    .rst_n             (`SPARC_CORE0.reset_l)
);

// I/O AXI splitter, needed for uart-hello-world.s
fake_uart fake_uart (
    .clk                ( chipset_clk         ),
    .rst_n              ( chipset_rst_n       ),

    .src_uart_noc2_val  ( buf_uart_noc2_valid ),
    .src_uart_noc2_data ( buf_uart_noc2_data  ),
    .src_uart_noc2_rdy  ( uart_buf_noc2_ready ),

    .uart_dst_noc3_val  ( uart_buf_noc3_valid ),
    .uart_dst_noc3_data ( uart_buf_noc3_data  ),
    .uart_dst_noc3_rdy  ( buf_uart_noc3_ready )
);
`endif // endif PITONSYS_IOCTRL

// Add the SRAM as an independent module instead being part of the memory controller
`ifdef PITONSYS_MEEP
    `ifdef MEEP_SRAM
 sram_top sram_top(
            .sys_clk(chipset_clk),
            .sys_rst_n(chipset_rst_n),
            .mc_clk(chipset_clk),

             .sram_flit_in_data(buf_sram_noc2_data),
             .sram_flit_in_val(buf_sram_noc2_valid),
             .sram_flit_in_rdy(sram_buf_noc2_ready),

             .sram_flit_out_data(sram_buf_noc3_data),
             .sram_flit_out_val(sram_buf_noc3_valid),
             .sram_flit_out_rdy(buf_sram_noc3_ready),

            // AXI Write Address Channel Signals
            .m_axi_awid(sram_axi_awid),
            .m_axi_awaddr(sram_axi_awaddr),
            .m_axi_awlen(sram_axi_awlen),
            .m_axi_awsize(sram_axi_awsize),
            .m_axi_awburst(sram_axi_awburst),
            .m_axi_awlock(sram_axi_awlock),
            .m_axi_awcache(sram_axi_awcache),
            .m_axi_awprot(sram_axi_awprot),
            .m_axi_awqos(sram_axi_awqos),
            .m_axi_awregion(sram_axi_awregion),
            .m_axi_awuser(sram_axi_awuser),
            .m_axi_awvalid(sram_axi_awvalid),
            .m_axi_awready(sram_axi_awready),

            // AXI Write Data Channel Signals
            .m_axi_wid(sram_axi_wid),
            .m_axi_wdata(sram_axi_wdata),
            .m_axi_wstrb(sram_axi_wstrb),
            .m_axi_wlast(sram_axi_wlast),
            .m_axi_wuser(sram_axi_wuser),
            .m_axi_wvalid(sram_axi_wvalid),
            .m_axi_wready(sram_axi_wready),

            // AXI Read Address Channel Signals
            .m_axi_arid(sram_axi_arid),
            .m_axi_araddr(sram_axi_araddr),
            .m_axi_arlen(sram_axi_arlen),
            .m_axi_arsize(sram_axi_arsize),
            .m_axi_arburst(sram_axi_arburst),
            .m_axi_arlock(sram_axi_arlock),
            .m_axi_arcache(sram_axi_arcache),
            .m_axi_arprot(sram_axi_arprot),
            .m_axi_arqos(sram_axi_arqos),
            .m_axi_arregion(sram_axi_arregion),
            .m_axi_aruser(sram_axi_aruser),
            .m_axi_arvalid(sram_axi_arvalid),
            .m_axi_arready(sram_axi_arready),

            // AXI Read Data Channel Signals
            .m_axi_rid(sram_axi_rid),
            .m_axi_rdata(sram_axi_rdata),
            .m_axi_rresp(sram_axi_rresp),
            .m_axi_rlast(sram_axi_rlast),
            .m_axi_ruser(sram_axi_ruser),
            .m_axi_rvalid(sram_axi_rvalid),
            .m_axi_rready(sram_axi_rready),

            // AXI Write Response Channel Signals
            .m_axi_bid(sram_axi_bid),
            .m_axi_bresp(sram_axi_bresp),
            .m_axi_buser(sram_axi_buser),
            .m_axi_bvalid(sram_axi_bvalid),
            .m_axi_bready(sram_axi_bready)
        );
	`endif
		
	`ifdef PITON_NONCACH_MEM

		ncmem_top ncmem_top_i  (
			.mc_clk             (ncmem_axi_aclk      ), 
            .mc_rstn            (ncmem_axi_arstn     ),    
			.core_ref_clk       (chipset_clk         ),
			.core_ref_rstn	    (chipset_rst_n       ),
			.phy_init_done      (hbm_calib_complete  ),

			.ncmem_flit_in_val  (buf_dma_pool_noc2_valid ),			
            .ncmem_flit_in_data (buf_dma_pool_noc2_data  ),
			.ncmem_flit_in_rdy  (dma_pool_buf_noc2_ready ),
                   
            .ncmem_flit_out_val  (dma_pool_buf_noc3_valid ),			
            .ncmem_flit_out_data (dma_pool_buf_noc3_data  ),			
			.ncmem_flit_out_rdy  (buf_dma_pool_noc3_ready ),

			.m_axi_awid(ncmem_axi_awid),
			.m_axi_awaddr(ncmem_axi_awaddr),
			.m_axi_awlen(ncmem_axi_awlen),
			.m_axi_awsize(ncmem_axi_awsize),
			.m_axi_awburst(ncmem_axi_awburst),
			.m_axi_awlock(ncmem_axi_awlock),
			.m_axi_awcache(ncmem_axi_awcache),
			.m_axi_awprot(ncmem_axi_awprot),
			.m_axi_awqos(ncmem_axi_awqos),
			.m_axi_awregion(ncmem_axi_awregion),
			.m_axi_awuser(ncmem_axi_awuser),
			.m_axi_awvalid(ncmem_axi_awvalid),
			.m_axi_awready(ncmem_axi_awready),

			.m_axi_wid(ncmem_axi_wid),
			.m_axi_wdata(ncmem_axi_wdata),
			.m_axi_wstrb(ncmem_axi_wstrb),
			.m_axi_wlast(ncmem_axi_wlast),
			.m_axi_wuser(ncmem_axi_wuser),
			.m_axi_wvalid(ncmem_axi_wvalid),
			.m_axi_wready(ncmem_axi_wready),

			.m_axi_bid(ncmem_axi_bid),
			.m_axi_bresp(ncmem_axi_bresp),
			.m_axi_buser(ncmem_axi_buser),
			.m_axi_bvalid(ncmem_axi_bvalid),
			.m_axi_bready(ncmem_axi_bready),

			.m_axi_arid(ncmem_axi_arid),
			.m_axi_araddr(ncmem_axi_araddr),
			.m_axi_arlen(ncmem_axi_arlen),
			.m_axi_arsize(ncmem_axi_arsize),
			.m_axi_arburst(ncmem_axi_arburst),
			.m_axi_arlock(ncmem_axi_arlock),
			.m_axi_arcache(ncmem_axi_arcache),
			.m_axi_arprot(ncmem_axi_arprot),
			.m_axi_arqos(ncmem_axi_arqos),
			.m_axi_arregion(ncmem_axi_arregion),
			.m_axi_aruser(ncmem_axi_aruser),
			.m_axi_arvalid(ncmem_axi_arvalid),
			.m_axi_arready(ncmem_axi_arready),

			.m_axi_rid(ncmem_axi_rid),
			.m_axi_rdata(ncmem_axi_rdata),
			.m_axi_rresp(ncmem_axi_rresp),
			.m_axi_rlast(ncmem_axi_rlast),
			.m_axi_ruser(ncmem_axi_ruser),
			.m_axi_rvalid(ncmem_axi_rvalid),
			.m_axi_rready(ncmem_axi_rready)
		 );
	`endif // PITONSYS_NON_CACH_MEM
`endif // MEEP


/////////////////////////////
// Ariane-Specific Chipset //
/////////////////////////////

`ifdef PITON_ARIANE

    wire [NUM_INTR_ETH+1-1:0] irq_sources, irq_le;
    // 0:level 1:edge
    // Eth is edge, Uart is level
    wire [NUM_INTR_ETH-1:0] irq_eth_le = 0;

    assign irq_le      = {irq_eth_le, 1'b0};
    assign irq_sources = {net_interrupt, uart_interrupt};

    // this is for selecting the right bootrom (1: baremetal, 0: linux)
    wire ariane_boot_sel;
`ifdef PITON_FPGA_SYNTH
  `ifndef ALVEOU280_BOARD
     assign ariane_boot_sel = uart_boot_en;
  `else
    `ifdef PITONSYS_UART_BOOT
       assign ariane_boot_sel = uart_boot_en;
    `else
       assign ariane_boot_sel = 1'b0;
    `endif
  `endif
`else
  `ifdef ARIANE_SIM_LINUX_BOOT
    assign ariane_boot_sel = 1'b0;
  `else
    assign ariane_boot_sel = 1'b1;
  `endif
`endif

<%
DmBase    = 0
RomBase   = 0
ClintBase = 0
PlicBase  = 0
for i in range(len(devices)):
    if devices[i]["name"] == "ariane_debug":
        DmBase = devices[i]["base"]
    if devices[i]["name"] == "ariane_bootrom":
        RomBase = devices[i]["base"]
    if devices[i]["name"] == "ariane_clint":
        ClintBase = devices[i]["base"]
    if devices[i]["name"] == "ariane_plic":
        PlicBase = devices[i]["base"]
str = '''
    riscv_peripherals #(
        .DataWidth      ( `NOC_DATA_WIDTH ),
        .NumHarts       ( `PITON_NUM_TILES),
        .NumSources     ( NUM_INTR_RISCV  ),
        .SwapEndianess  (               1 ),
        .DmBase         ( 64'h%016x ),
        .RomBase        ( 64'h%016x ),
        .ClintBase      ( 64'h%016x ),
        .PlicBase       ( 64'h%016x )
    ) i_riscv_peripherals (
        .clk_i                           ( chipset_clk                   ),
        .rst_ni                          ( chipset_rst_n                 ),
        .testmode_i                      ( 1'b0                          ),
        `ifdef DEBUG_ROM 
         .debug_rom_en                   ( debug_rom_en                  ),
         .debug_rom_req                  ( debug_rom_req                 ),
         .debug_rom_addr                 ( debug_rom_addr                ),
         .debug_rom_rdata                ( debug_rom_rdata               ),
        `endif
        .buf_ariane_debug_noc2_data_i    ( buf_ariane_debug_noc2_data    ),
        .buf_ariane_debug_noc2_valid_i   ( buf_ariane_debug_noc2_valid   ),
        .ariane_debug_buf_noc2_ready_o   ( ariane_debug_buf_noc2_ready   ),
        .ariane_debug_buf_noc3_data_o    ( ariane_debug_buf_noc3_data    ),
        .ariane_debug_buf_noc3_valid_o   ( ariane_debug_buf_noc3_valid   ),
        .buf_ariane_debug_noc3_ready_i   ( buf_ariane_debug_noc3_ready   ),
        .buf_ariane_bootrom_noc2_data_i  ( buf_ariane_bootrom_noc2_data  ),
        .buf_ariane_bootrom_noc2_valid_i ( buf_ariane_bootrom_noc2_valid ),
        .ariane_bootrom_buf_noc2_ready_o ( ariane_bootrom_buf_noc2_ready ),
        .ariane_bootrom_buf_noc3_data_o  ( ariane_bootrom_buf_noc3_data  ),
        .ariane_bootrom_buf_noc3_valid_o ( ariane_bootrom_buf_noc3_valid ),
        .buf_ariane_bootrom_noc3_ready_i ( buf_ariane_bootrom_noc3_ready ),
        .buf_ariane_clint_noc2_data_i    ( buf_ariane_clint_noc2_data    ),
        .buf_ariane_clint_noc2_valid_i   ( buf_ariane_clint_noc2_valid   ),
        .ariane_clint_buf_noc2_ready_o   ( ariane_clint_buf_noc2_ready   ),
        .ariane_clint_buf_noc3_data_o    ( ariane_clint_buf_noc3_data    ),
        .ariane_clint_buf_noc3_valid_o   ( ariane_clint_buf_noc3_valid   ),
        .buf_ariane_clint_noc3_ready_i   ( buf_ariane_clint_noc3_ready   ),
        .buf_ariane_plic_noc2_data_i     ( buf_ariane_plic_noc2_data     ),
        .buf_ariane_plic_noc2_valid_i    ( buf_ariane_plic_noc2_valid    ),
        .ariane_plic_buf_noc2_ready_o    ( ariane_plic_buf_noc2_ready    ),
        .ariane_plic_buf_noc3_data_o     ( ariane_plic_buf_noc3_data     ),
        .ariane_plic_buf_noc3_valid_o    ( ariane_plic_buf_noc3_valid    ),
        .buf_ariane_plic_noc3_ready_i    ( buf_ariane_plic_noc3_ready    ),
        // This selects either the BM or linux bootrom
        .ariane_boot_sel_i               ( ariane_boot_sel               ),
        // Debug sigs to cores
        .ndmreset_o                      ( ndmreset_o                    ),
        .dmactive_o                      ( dmactive_o                    ),
        .debug_req_o                     ( debug_req_o                   ),
        .unavailable_i                   ( unavailable_i                 ),
        // JTAG
        .tck_i                           ( tck_i                         ),
        .tms_i                           ( tms_i                         ),
        .trst_ni                         ( trst_ni                       ),
        .td_i                            ( td_i                          ),
        .td_o                            ( td_o                          ),
        .tdo_oe_o                        (                               ),
        // CLINT
        .rtc_i                           ( rtc_i                         ),
        .timer_irq_o                     ( timer_irq_o                   ),
        .ipi_o                           ( ipi_o                         ),
        // PLIC
        .irq_le_i                        ( irq_le                        ), // 0:level 1:edge
        .irq_sources_i                   ( irq_sources                   ),
        .irq_o                           ( irq_o                         )
    );
''' % (int(DmBase), int(RomBase), int(ClintBase), int(PlicBase))
print(str)
%>



/////////////////////////////
// Lagarto-Specific Chipset //
/////////////////////////////

`elsif PITON_LAGARTO

    wire [NUM_INTR_ETH+1-1:0] irq_sources, irq_le;
    // 0:level 1:edge
    // Eth is edge, Uart is level
    wire [NUM_INTR_ETH-1:0] irq_eth_le = 0;

    assign irq_le      = {irq_eth_le, 1'b0};
    assign irq_sources = {net_interrupt, uart_interrupt};


    // this is for selecting the right bootrom (1: baremetal, 0: linux)
    wire lagarto_boot_sel;
`ifdef PITON_FPGA_SYNTH
  `ifndef ALVEOU280_BOARD
     assign lagarto_boot_sel = uart_boot_en;
  `else
    `ifdef PITONSYS_UART_BOOT
       assign lagarto_boot_sel = uart_boot_en;
    `else
       assign lagarto_boot_sel = 1'b0;
    `endif
  `endif
`else
  `ifdef LAGARTO_SIM_LINUX_BOOT
    assign lagarto_boot_sel = 1'b0;
  `else
    assign lagarto_boot_sel = 1'b1;
  `endif
`endif

    // PMU
 //   noc_pmu #(
 //       .TILE_COUNT(`PITON_NUM_TILES)
 //   ) pmu (
 //       .noc_clk(chipset_clk),
 //       .buf_noc2_data_i     ( buf_lagarto_pmu_noc2_data     ),
 //       .buf_noc2_valid_i    ( buf_lagarto_pmu_noc2_valid    ),
 //       .buf_noc2_ready_o    ( lagarto_pmu_buf_noc2_ready    ),
 //       .buf_noc3_data_o     ( lagarto_pmu_buf_noc3_data     ),
 //       .buf_noc3_valid_o    ( lagarto_pmu_buf_noc3_valid    ),
 //       .buf_noc3_ready_i    ( buf_lagarto_pmu_noc3_ready    ),

 //       .rst(chipset_rst_n),
 //       .counter_clk(pmu_clk),
 //       .pmu_sig_i(pmu_sig_i));


<%
DmBase    = 0
RomBase   = 0
ClintBase = 0
PlicBase  = 0
for i in range(len(devices)):
    if devices[i]["name"] == "lagarto_debug":
        DmBase = devices[i]["base"]
    if devices[i]["name"] == "lagarto_bootrom":
        RomBase = devices[i]["base"]
    if devices[i]["name"] == "lagarto_clint":
        ClintBase = devices[i]["base"]
    if devices[i]["name"] == "lagarto_plic":
        PlicBase = devices[i]["base"]
str = '''
    riscv_peripherals #(
        .DataWidth      ( `NOC_DATA_WIDTH ),
        .NumHarts       ( `PITON_NUM_TILES),
        .NumSources     ( NUM_INTR_RISCV  ),
        .SwapEndianess  (               1 ),
        .DmBase         ( 64'h%016x ),
        .RomBase        ( 64'h%016x ),
        .ClintBase      ( 64'h%016x ),
        .PlicBase       ( 64'h%016x )
    ) i_riscv_peripherals (
        .clk_i                           ( chipset_clk                    ),
        .rst_ni                          ( chipset_rst_n                  ),
        .testmode_i                      ( 1'b0                           ),
       `ifdef DEBUG_ROM 
        .debug_rom_en                    ( debug_rom_en                   ),
        .debug_rom_req                   ( debug_rom_req                  ),
        .debug_rom_addr                  ( debug_rom_addr                 ),
        .debug_rom_rdata                 ( debug_rom_rdata                ),
       `endif
        .buf_ariane_debug_noc2_data_i    ( buf_lagarto_debug_noc2_data    ),
        .buf_ariane_debug_noc2_valid_i   ( buf_lagarto_debug_noc2_valid   ),
        .ariane_debug_buf_noc2_ready_o   ( lagarto_debug_buf_noc2_ready   ),
        .ariane_debug_buf_noc3_data_o    ( lagarto_debug_buf_noc3_data    ),
        .ariane_debug_buf_noc3_valid_o   ( lagarto_debug_buf_noc3_valid   ),
        .buf_ariane_debug_noc3_ready_i   ( buf_lagarto_debug_noc3_ready   ),
        .buf_ariane_bootrom_noc2_data_i  ( buf_lagarto_bootrom_noc2_data  ),
        .buf_ariane_bootrom_noc2_valid_i ( buf_lagarto_bootrom_noc2_valid ),
        .ariane_bootrom_buf_noc2_ready_o ( lagarto_bootrom_buf_noc2_ready ),
        .ariane_bootrom_buf_noc3_data_o  ( lagarto_bootrom_buf_noc3_data  ),
        .ariane_bootrom_buf_noc3_valid_o ( lagarto_bootrom_buf_noc3_valid ),
        .buf_ariane_bootrom_noc3_ready_i ( buf_lagarto_bootrom_noc3_ready ),
        .buf_ariane_clint_noc2_data_i    ( buf_lagarto_clint_noc2_data    ),
        .buf_ariane_clint_noc2_valid_i   ( buf_lagarto_clint_noc2_valid   ),
        .ariane_clint_buf_noc2_ready_o   ( lagarto_clint_buf_noc2_ready   ),
        .ariane_clint_buf_noc3_data_o    ( lagarto_clint_buf_noc3_data    ),
        .ariane_clint_buf_noc3_valid_o   ( lagarto_clint_buf_noc3_valid   ),
        .buf_ariane_clint_noc3_ready_i   ( buf_lagarto_clint_noc3_ready   ),
        .buf_ariane_plic_noc2_data_i     ( buf_lagarto_plic_noc2_data     ),
        .buf_ariane_plic_noc2_valid_i    ( buf_lagarto_plic_noc2_valid    ),
        .ariane_plic_buf_noc2_ready_o    ( lagarto_plic_buf_noc2_ready    ),
        .ariane_plic_buf_noc3_data_o     ( lagarto_plic_buf_noc3_data     ),
        .ariane_plic_buf_noc3_valid_o    ( lagarto_plic_buf_noc3_valid    ),
        .buf_ariane_plic_noc3_ready_i    ( buf_lagarto_plic_noc3_ready    ),
        // This selects either the BM or linux bootrom
        .ariane_boot_sel_i               ( lagarto_boot_sel               ),
        // Debug sigs to cores
        .ndmreset_o                      ( ndmreset_o                    ),
        .dmactive_o                      ( dmactive_o                    ),
        .debug_req_o                     ( debug_req_o                   ),
        .unavailable_i                   ( unavailable_i                 ),
        // JTAG
        .tck_i                           ( tck_i                         ),
        .tms_i                           ( tms_i                         ),
        .trst_ni                         ( trst_ni                       ),
        .td_i                            ( td_i                          ),
        .td_o                            ( td_o                          ),
        .tdo_oe_o                        (                               ),
        // CLINT
        .rtc_i                           ( rtc_i                         ),
        .timer_irq_o                     ( timer_irq_o                   ),
        .ipi_o                           ( ipi_o                         ),
        // PLIC
        .irq_le_i                        ( irq_le                        ), // 0:level 1:edge
        .irq_sources_i                   ( irq_sources                   ),
        .irq_o                           ( irq_o                         )
    );
''' % (int(DmBase), int(RomBase), int(ClintBase), int(PlicBase))
print(str)
%>

`else

    // tie off unused sigs
    assign ariane_debug_buf_noc2_ready   = 1'b0;
    assign ariane_debug_buf_noc3_data    = `NOC_DATA_WIDTH'b0;
    assign ariane_debug_buf_noc3_valid   = 1'b0;

    assign ariane_bootrom_buf_noc2_ready = 1'b0;
    assign ariane_bootrom_buf_noc3_data  = `NOC_DATA_WIDTH'b0;
    assign ariane_bootrom_buf_noc3_valid = 1'b0;

    assign ariane_clint_buf_noc2_ready   = 1'b0;
    assign ariane_clint_buf_noc3_data    = `NOC_DATA_WIDTH'b0;
    assign ariane_clint_buf_noc3_valid   = 1'b0;

    assign ariane_plic_buf_noc2_ready    = 1'b0;
    assign ariane_plic_buf_noc3_data     = `NOC_DATA_WIDTH'b0;
    assign ariane_plic_buf_noc3_valid    = 1'b0;

`endif

endmodule
